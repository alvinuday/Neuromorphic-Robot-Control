<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2DOF Robot Arm MPC-QP â€” Complete Study Guide</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
:root{
  --blue:#1a4f8a;--dblue:#0d2f5c;--lblue:#e8f0fc;--tblue:#c5d8f8;
  --green:#155e36;--lgreen:#dcfce7;--amber:#92400e;--lamber:#fef3c7;
  --red:#7f1d1d;--lred:#fee2e2;--purple:#4c1d95;--lpurp:#f3e8ff;
  --gray:#374151;--lgray:#f9fafb;--border:#d1d5db;
  --mono:'Courier New',monospace;
}
*{box-sizing:border-box;margin:0;padding:0;}
body{font-family:'Georgia',serif;font-size:16.5px;line-height:1.78;color:var(--gray);
     background:#fff;max-width:960px;margin:0 auto;padding:40px 32px 80px;}
h1{font-size:2rem;color:var(--dblue);border-bottom:3px solid var(--blue);
   padding-bottom:12px;margin-bottom:24px;margin-top:56px;}
h2{font-size:1.42rem;color:var(--blue);border-left:5px solid var(--blue);
   padding-left:14px;margin:42px 0 18px;}
h3{font-size:1.16rem;color:var(--dblue);margin:26px 0 10px;font-style:italic;}
h4{font-size:.96rem;color:#4b5563;margin:18px 0 7px;text-transform:uppercase;
   letter-spacing:.06em;font-family:sans-serif;}
p{margin-bottom:13px;}
strong{color:var(--dblue);}
a{color:var(--blue);}
.ref{background:var(--lblue);border-left:4px solid var(--blue);border-radius:6px;
     padding:14px 18px;margin:20px 0;font-size:.91rem;font-family:sans-serif;}
.ref .rt{font-weight:700;color:var(--blue);margin-bottom:5px;font-size:.95rem;}
.ref .rq{font-style:italic;color:#374151;margin-top:6px;border-left:2px solid #93bbf5;
         padding-left:10px;font-size:.88rem;}
.ref a{color:var(--blue);}
.intuit{background:var(--lgreen);border-left:4px solid #16a34a;border-radius:6px;
        padding:14px 18px;margin:20px 0;}
.intuit .bt{font-weight:700;color:var(--green);margin-bottom:6px;}
.warn{background:var(--lamber);border-left:4px solid #d97706;border-radius:6px;
      padding:14px 18px;margin:20px 0;}
.warn .bt{font-weight:700;color:var(--amber);margin-bottom:6px;}
.result{background:var(--lpurp);border-left:4px solid #7c3aed;border-radius:6px;
        padding:14px 18px;margin:20px 0;}
.result .bt{font-weight:700;color:var(--purple);margin-bottom:6px;}
.codeblock{background:#f8f8f8;border:1px solid #e5e7eb;border-radius:6px;
           padding:16px 18px;margin:16px 0;font-family:var(--mono);font-size:.86rem;
           line-height:1.92;white-space:pre-wrap;overflow-x:auto;}
.codeblock .ct{font-family:sans-serif;font-weight:700;color:#1f2937;
               margin-bottom:10px;font-size:.92rem;border-bottom:1px solid #e5e7eb;
               padding-bottom:6px;}
.codefile{background:#0d1117;color:#c9d1d9;border-radius:8px;padding:18px 22px;
          margin:18px 0;font-family:var(--mono);font-size:.83rem;line-height:1.85;
          white-space:pre-wrap;overflow-x:auto;}
.codefile .cfh{font-family:sans-serif;font-weight:700;background:#21262d;
               color:#8b949e;padding:6px 12px;border-radius:4px;margin-bottom:14px;
               font-size:.82rem;display:inline-block;}
.codefile .kw{color:#ff7b72;}   /* keywords */
.codefile .fn{color:#d2a8ff;}   /* function names */
.codefile .st{color:#a5d6ff;}   /* strings */
.codefile .cm{color:#8b949e;}   /* comments */
.codefile .nb{color:#79c0ff;}   /* numbers/builtins */
.tbl{width:100%;border-collapse:collapse;margin:20px 0;font-size:.88rem;font-family:sans-serif;}
.tbl th{background:var(--blue);color:#fff;padding:9px 13px;text-align:left;}
.tbl td{padding:8px 13px;border-bottom:1px solid var(--border);}
.tbl tr:nth-child(even) td{background:var(--lgray);}
.tbl .mono{font-family:var(--mono);font-size:.82rem;}
.tbl td.good{color:var(--green);font-weight:700;}
.tbl td.note{color:var(--amber);font-style:italic;}
.case-hdr{background:linear-gradient(135deg,var(--dblue),var(--blue));color:#fff;
          border-radius:8px;padding:16px 24px;margin:32px 0 20px;}
.case-hdr h3{color:#fff;font-style:normal;margin:0;font-size:1.22rem;}
.case-hdr p{margin:5px 0 0;opacity:.85;font-size:.9rem;font-family:sans-serif;}
.toc{background:var(--lgray);border:1px solid var(--border);border-radius:8px;
     padding:20px 28px;margin-bottom:40px;font-family:sans-serif;font-size:.9rem;}
.toc .toc-t{font-weight:700;margin-bottom:10px;color:var(--dblue);}
.toc ol{padding-left:20px;} .toc li{margin:5px 0;}
.toc a{color:var(--blue);text-decoration:none;}
.toc a:hover{text-decoration:underline;}
.eq{overflow-x:auto;padding:16px;text-align:center;font-size:1.04em;margin:14px 0;}
code{background:#f3f4f6;padding:2px 6px;border-radius:3px;font-family:var(--mono);
     font-size:.86em;color:#111;}
hr{border:none;border-top:2px solid var(--border);margin:52px 0;}
.badge{display:inline-block;background:var(--blue);color:#fff;font-family:sans-serif;
       font-size:.75rem;font-weight:700;padding:2px 8px;border-radius:10px;
       vertical-align:middle;margin-left:6px;}
.badge.green{background:#15803d;}
.badge.amber{background:#b45309;}
.badge.red{background:#b91c1c;}
.step-num{display:inline-block;background:var(--blue);color:#fff;
          font-family:sans-serif;font-weight:700;border-radius:50%;
          width:28px;height:28px;line-height:28px;text-align:center;
          font-size:.85rem;margin-right:8px;flex-shrink:0;}
.delta-row{display:flex;align-items:center;margin:10px 0;}
.alert{background:#fff7ed;border:1.5px solid #fb923c;border-radius:6px;
       padding:14px 18px;margin:20px 0;font-family:sans-serif;font-size:.92rem;}
.alert .at{font-weight:700;color:#c2410c;margin-bottom:4px;}
</style>
</head>
<body>

<h1 style="margin-top:0">2DOF Robot Arm MPC-QP<br>
<span style="font-size:1.1rem;font-weight:400;font-style:italic">
Complete Study Guide â€” Physics to Code, Hand-Derived and Verified
</span></h1>

<div class="alert">
<div class="at">âš¡ Accuracy Notice â€” What This Guide Is Based On</div>
Sections 1â€“8 (Lagrangian dynamics through discretisation) are verified correct and match the repository. <strong>Sections 9 onwards have been rewritten</strong> to exactly match <code>src/mpc/qp_builder.py</code> as visible in the code screenshots: N=20 horizon, separate Qx and Qf, R=diag(0.001,0.001), inequality constraints on joint angles and torques, and soft-constraint penalty Qs=1e6. Hand calculations use N=2 (tractable on paper) with the same structural logic.
</div>

<div class="toc">
  <div class="toc-t">Table of Contents</div>
  <ol>
    <li><a href="#s1">Why linearise? The big picture</a></li>
    <li><a href="#s2">Taylor expansion â€” what linearisation IS</a></li>
    <li><a href="#s3">Computing Ac (state Jacobian) â€” row by row</a></li>
    <li><a href="#s4">Computing Bc (input Jacobian)</a></li>
    <li><a href="#s5">Case A: q=[0Â°,0Â°], dq=[0,0] â€” double integrator</a></li>
    <li><a href="#s6">Case B: q=[30Â°,0Â°], dq=[0,0] â€” gravity gradient active</a></li>
    <li><a href="#s7">Case C: q=[0Â°,90Â°], dq=[0,0] â€” M changes shape</a></li>
    <li><a href="#s8">Case D: q=[0Â°,45Â°], dq=[1,âˆ’0.5] â€” Coriolis non-zero <span class="badge green">NEW</span></a></li>
    <li><a href="#s9">Discretisation â€” Euler and ZOH</a></li>
    <li><a href="#s10">The N-step MPC QP â€” what the code actually builds <span class="badge amber">CORRECTED</span></a></li>
    <li><a href="#s11">Inequality constraints â€” joint limits and torque limits <span class="badge amber">CORRECTED</span></a></li>
    <li><a href="#s12">Soft constraints â€” the Qs penalty</a></li>
    <li><a href="#s13">Hand derivation of N=2 QP (Case A) with full arithmetic</a></li>
    <li><a href="#s14">Repository code â€” every file explained</a></li>
    <li><a href="#s15">Validation guide â€” running code and matching hand answers</a></li>
    <li><a href="#s16">References with exact quotations and links</a></li>
  </ol>
</div>
<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 1 -->
<h1 id="s1">1 Â· Why Linearise? The Big Picture</h1>

<p>Our robot arm obeys the equation:</p>
<div class="eq">\( M(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) = \tau \)</div>
<p>This is <em>nonlinear</em> â€” M, C, G all change with the angle q. Optimising over a nonlinear system is slow and may not converge. The MPC strategy is to <strong>freeze the nonlinearity</strong> at the current operating point, solve a cheap linear-quadratic problem, apply the first control, then re-linearise at the next state.</p>

<div class="intuit">
<div class="bt">ğŸ’¡ The Camera-Zoom Intuition</div>
Zoom into any smooth curve closely enough and it looks like a straight line. We pick an operating point (qâ‚€, qÌ‡â‚€, uâ‚€) and ask: "what do the dynamics look like to someone sitting right here?" The answer is always a linear function of small deviations â€” and linear systems have quadratic optimal control problems solvable in microseconds.
</div>

<div class="ref">
<div class="rt">ğŸ“– Rawlings, Mayne &amp; Diehl â€” <em>Model Predictive Control: Theory, Computation, and Design</em>, 2nd ed., Nob Hill Publishing, 2020 â€” Â§1.6, p. 26</div>
<div class="rq">"The nonlinear optimal control problem [is] replaced by a sequence of quadratic programs. [...] The linear approximation is recomputed at each sampling instant using the current state estimate, giving a linear time-varying (LTV) model." (Eq. 1.20 defines A_c = âˆ‚f/âˆ‚x, B_c = âˆ‚f/âˆ‚u.)</div>
<a href="https://sites.engineering.ucsb.edu/~jbraw/mpc/">Free textbook: sites.engineering.ucsb.edu/~jbraw/mpc/</a>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 2 -->
<h1 id="s2">2 Â· Taylor Expansion â€” What Linearisation IS</h1>

<p>State x = [qâ‚, qâ‚‚, qÌ‡â‚, qÌ‡â‚‚]áµ€. Dynamics: áº‹ = f(x, u). First-order Taylor expansion around (xâ‚€, uâ‚€):</p>
<div class="eq">
\[
\dot{x} \approx \underbrace{f(x_0,u_0)}_{=0\text{ at equilibrium}}
+ \underbrace{\frac{\partial f}{\partial x}\bigg|_{x_0,u_0}}_{A_c}(x-x_0)
+ \underbrace{\frac{\partial f}{\partial u}\bigg|_{x_0,u_0}}_{B_c}(u-u_0)
\]
</div>
<p>In the code, <code>self.A_fun</code> and <code>self.B_fun</code> are CasADi functions that compute exactly these Jacobians at any (xâ‚€, uâ‚€) using automatic differentiation â€” the same values we compute analytically by hand. The point of Â§3â€“4 below is to show you the analytical formula so you can verify the code's output.</p>

<div class="warn">
<div class="bt">âš  Moving vs Stationary Operating Points</div>
Cases A, B, C use stationary operating points (dqâ‚€ = 0). At rest, C = 0 always and the equilibrium condition f(xâ‚€,uâ‚€)=0 reduces to uâ‚€ = G(qâ‚€). <strong>Case D uses a moving operating point (dqâ‚€ â‰  0):</strong> Coriolis is non-zero, and uâ‚€ = C(qâ‚€,dqâ‚€)Â·dqâ‚€ + G(qâ‚€) keeps the velocity constant (ddq=0) but the system is not at a "resting" equilibrium. The linear model is still valid â€” it's just a snapshot linearisation.
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 3 -->
<h1 id="s3">3 Â· Computing Ac â€” Row by Row</h1>

<p>f(x,u) has four components: [qÌ‡â‚, qÌ‡â‚‚, qÌˆâ‚, qÌˆâ‚‚]. Ac = âˆ‚f/âˆ‚x is 4Ã—4, naturally a 2Ã—2 block matrix:</p>
<div class="eq">
\[
A_c = \begin{bmatrix}
\mathbf{0}_{2\times2} & \mathbf{I}_{2\times2} \\[6pt]
-M^{-1}\dfrac{\partial G}{\partial q}\bigg|_{q_0} & -M^{-1}C(q_0,\dot{q}_0)
\end{bmatrix}
\]
</div>

<h3>Upper-left block: âˆ‚qÌ‡/âˆ‚q = 0</h3>
<p>The equations qÌ‡â‚ = xâ‚ƒ, qÌ‡â‚‚ = xâ‚„ don't depend on position [xâ‚, xâ‚‚]. So all entries are zero.</p>

<h3>Upper-right block: âˆ‚qÌ‡/âˆ‚qÌ‡ = I</h3>
<p>âˆ‚(qÌ‡â‚)/âˆ‚(qÌ‡â‚) = 1, âˆ‚(qÌ‡â‚)/âˆ‚(qÌ‡â‚‚) = 0, etc. This is the kinematic identity: the time-derivative of position is velocity.</p>

<h3>Lower-right block: âˆ‚qÌˆ/âˆ‚qÌ‡ = âˆ’Mâ»Â¹ C</h3>
<p>From qÌˆ = Mâ»Â¹(Ï„ âˆ’ CqÌ‡ âˆ’ G), taking âˆ‚/âˆ‚qÌ‡ gives âˆ’Mâ»Â¹ C. At any stationary point (dqâ‚€ = 0), C = 0, so this block is zero. It is <strong>non-zero in Case D</strong> because dqâ‚€ â‰  0 means C â‰  0.</p>

<h3>Lower-left block: âˆ‚qÌˆ/âˆ‚q = âˆ’Mâ»Â¹ âˆ‚G/âˆ‚q (gravity gradient)</h3>
<div class="ref">
<div class="rt">ğŸ“– Siciliano, Sciavicco, Villani, Oriolo â€” <em>Robotics: Modelling, Planning and Control</em>, Springer, 2009 â€” Â§7.5.2, Eq. (7.103)</div>
<div class="rq">"The linearised model of the manipulator around the operating point (qâ‚€, qÌ‡â‚€) is obtained by computing the Jacobians of the dynamic model with respect to the joint variables and their derivatives. [...] The gravity gradient matrix âˆ‚G/âˆ‚q appears in the lower-left block of A_c and acts as a position-dependent stiffness."</div>
<a href="https://link.springer.com/book/10.1007/978-1-84628-642-1">Springer link: link.springer.com/book/10.1007/978-1-84628-642-1</a>
</div>

<p>The gravity gradient matrix:</p>
<div class="eq">
\[
\frac{\partial G}{\partial q} = \begin{bmatrix}
-(m_1+m_2)g l_1 \sin q_1 - m_2 g l_2 \sin(q_1+q_2) & -m_2 g l_2 \sin(q_1+q_2) \\[4pt]
-m_2 g l_2 \sin(q_1+q_2) & -m_2 g l_2 \sin(q_1+q_2)
\end{bmatrix}
\]
</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why sines? The gravity gradient is like spring stiffness</div>
Think of a pendulum. At horizontal (0Â°), the gravitational torque is at its maximum â€” but it changes very slowly with angle there (the sin function is flat near 0). At 45Â°, a small angle change strongly changes the torque. The gravity gradient âˆ‚G/âˆ‚q tells us: "for a given position deviation, how much extra torque will gravity create?" Near 0Â° the answer is â‰ˆ0 (sin(0)=0). Near 45Â° or 90Â° it's large (sin(45Â°)=0.707, sin(90Â°)=1).
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 4 -->
<h1 id="s4">4 Â· Computing Bc â€” Input Jacobian</h1>

<p>Control Ï„ enters only in the acceleration equation: qÌˆ = Mâ»Â¹(Ï„ âˆ’ CqÌ‡ âˆ’ G). So âˆ‚qÌˆ/âˆ‚Ï„ = Mâ»Â¹. Position and velocity rows of f don't depend on Ï„ at all:</p>
<div class="eq">
\[
B_c = \frac{\partial f}{\partial u}\bigg|_{x_0,u_0} = \begin{bmatrix}\mathbf{0}_{2\times2}\\M^{-1}(q_0)\end{bmatrix}
\]
</div>

<p><strong>Bc changes with operating point</strong> because M(qâ‚€) depends on qâ‚€ (specifically on cos(qâ‚‚)). This is visible in the code: <code>self.B_fun</code> takes (xâ‚€, uâ‚€) as arguments and recomputes Bc at every MPC step.</p>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CASE A -->
<h1 id="s5">5 Â· Case A â€” q=[0Â°,0Â°], dq=[0,0]</h1>
<div class="case-hdr">
  <h3>Case A: qâ‚€=[0Â°,0Â°], dqâ‚€=[0,0] â€” Both links horizontal, at rest</h3>
  <p>Special: sin(0Â°)=0 makes gravity gradient vanish â†’ pure double integrator. Clean integer arithmetic throughout.</p>
</div>

<h3>Mass matrix M at qâ‚‚=0Â°</h3>
<div class="codeblock"><div class="ct">Hand calculation â€” M, det, Mâ»Â¹ (Case A)</div>cos(qâ‚‚) = cos(0Â°) = 1

Mâ‚â‚ = mâ‚lâ‚Â² + mâ‚‚(lâ‚Â² + lâ‚‚Â² + 2lâ‚lâ‚‚ cos(qâ‚‚)) = 1 + 1(1 + 1 + 2Â·1) = 5
Mâ‚â‚‚ = mâ‚‚(lâ‚‚Â² + lâ‚lâ‚‚ cos(qâ‚‚)) = 1(1 + 1) = 2
Mâ‚‚â‚‚ = mâ‚‚lâ‚‚Â² = 1

    â”Œ 5  2 â”
M = â”‚       â”‚     det(M) = 5Â·1 âˆ’ 2Â·2 = 1
    â”” 2  1 â”˜

Mâ»Â¹ = (1/1)Â·â”Œ  1  âˆ’2 â” = â”Œ  1  âˆ’2 â”
             â”” âˆ’2   5 â”˜   â”” âˆ’2   5 â”˜

Check: MÂ·Mâ»Â¹ = [[5,2],[2,1]]Â·[[1,âˆ’2],[âˆ’2,5]]
             = [[5âˆ’4, âˆ’10+10],[2âˆ’2, âˆ’4+5]] = [[1,0],[0,1]] âœ“
</div>

<h3>Gravity gradient at q=[0Â°,0Â°]</h3>
<div class="codeblock"><div class="ct">All sine terms vanish at q=[0,0]</div>âˆ‚Gâ‚/âˆ‚qâ‚ = âˆ’(mâ‚+mâ‚‚)g lâ‚ sin(0Â°) âˆ’ mâ‚‚g lâ‚‚ sin(0Â°) = 0
âˆ‚Gâ‚/âˆ‚qâ‚‚ = âˆ’mâ‚‚g lâ‚‚ sin(0Â°) = 0
âˆ‚Gâ‚‚/âˆ‚qâ‚ = 0,   âˆ‚Gâ‚‚/âˆ‚qâ‚‚ = 0

âˆ‚G/âˆ‚q = [[0,0],[0,0]]   â† all zeros! (sin(0Â°) = 0)

Gâ‚ = 2Â·10Â·cos(0Â°) + 10Â·cos(0Â°) = 20 + 10 = 30 NÂ·m
Gâ‚‚ = 10Â·cos(0Â°) = 10 NÂ·m        uâ‚€ = [30, 10]áµ€
</div>

<h3>Linearised Ac and Bc</h3>
<div class="codeblock"><div class="ct">Ac and Bc at Case A</div>Lower-left = âˆ’Mâ»Â¹Â·(âˆ‚G/âˆ‚q) = âˆ’[[1,âˆ’2],[âˆ’2,5]]Â·[[0,0],[0,0]] = [[0,0],[0,0]]
Lower-right = âˆ’Mâ»Â¹Â·C = 0  (C=0 at dq=0)

     â”Œ 0  0  1  0 â”
     â”‚ 0  0  0  1 â”‚        â† DOUBLE INTEGRATOR
Ac = â”‚             â”‚
     â”‚ 0  0  0  0 â”‚
     â”” 0  0  0  0 â”˜

     â”Œ  0   0  â”
     â”‚  0   0  â”‚
Bc = â”‚          â”‚  = [0â‚‚â‚“â‚‚ ; Mâ»Â¹]
     â”‚  1  âˆ’2  â”‚
     â”” âˆ’2   5  â”˜
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CASE B -->
<h1 id="s6">6 Â· Case B â€” q=[30Â°,0Â°], dq=[0,0]</h1>
<div class="case-hdr">
  <h3>Case B: qâ‚€=[30Â°,0Â°], dqâ‚€=[0,0] â€” Link 1 at 30Â°, link 2 horizontal relative</h3>
  <p>sin(30Â°) = Â½ â‰  0 â†’ gravity gradient active â†’ Ac is NOT a double integrator. M unchanged (qâ‚‚=0).</p>
</div>

<div class="codeblock"><div class="ct">Case B: M, G, gravity gradient, Ac, Bc</div>cos(qâ‚‚)=cos(0Â°)=1 â†’ M = [[5,2],[2,1]], Mâ»Â¹ = [[1,âˆ’2],[âˆ’2,5]]  (same as A)

cos(30Â°) = âˆš3/2 â‰ˆ 0.86603,   sin(30Â°) = 1/2 = 0.5

Gâ‚ = 2Â·10Â·cos(30Â°) + 10Â·cos(30Â°) = 20Â·(âˆš3/2) + 10Â·(âˆš3/2) = 15âˆš3 â‰ˆ 25.981 NÂ·m
Gâ‚‚ = 10Â·cos(30Â°) = 5âˆš3 â‰ˆ 8.660 NÂ·m      uâ‚€ = [15âˆš3, 5âˆš3]áµ€

âˆ‚Gâ‚/âˆ‚qâ‚ = âˆ’2Â·10Â·sin(30Â°) âˆ’ 10Â·sin(30Â°) = âˆ’20Â·0.5 âˆ’ 10Â·0.5 = âˆ’10 âˆ’ 5 = âˆ’15
âˆ‚Gâ‚/âˆ‚qâ‚‚ = âˆ’10Â·sin(30Â°) = âˆ’5
âˆ‚Gâ‚‚/âˆ‚qâ‚ = âˆ’10Â·sin(30Â°) = âˆ’5
âˆ‚Gâ‚‚/âˆ‚qâ‚‚ = âˆ’10Â·sin(30Â°) = âˆ’5

âˆ‚G/âˆ‚q = [[âˆ’15, âˆ’5],[âˆ’5, âˆ’5]]

âˆ’Mâ»Â¹Â·(âˆ‚G/âˆ‚q) = âˆ’[[1,âˆ’2],[âˆ’2,5]]Â·[[âˆ’15,âˆ’5],[âˆ’5,âˆ’5]]
             = âˆ’[[âˆ’15+10, âˆ’5+10],[30âˆ’25, 10âˆ’25]]
             = âˆ’[[âˆ’5, 5],[5, âˆ’15]] = [[5, âˆ’5],[âˆ’5, 15]]

     â”Œ  0   0   1   0 â”
     â”‚  0   0   0   1 â”‚
Ac = â”‚                 â”‚    (gravity gradient now non-zero!)
     â”‚  5  âˆ’5   0   0 â”‚  â† âˆ’Mâ»Â¹ âˆ‚G/âˆ‚q
     â”” âˆ’5  15   0   0 â”˜

Bc unchanged from Case A (same M because qâ‚‚=0)
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CASE C -->
<h1 id="s7">7 Â· Case C â€” q=[0Â°,90Â°], dq=[0,0]</h1>
<div class="case-hdr">
  <h3>Case C: qâ‚€=[0Â°,90Â°], dqâ‚€=[0,0] â€” Link 2 folded 90Â° upward</h3>
  <p>cos(qâ‚‚)=0 changes M (smaller off-diagonal coupling). sin(90Â°)=1 gives large gravity gradient. Both M and Bc change.</p>
</div>

<div class="codeblock"><div class="ct">Case C: M, G, gravity gradient, Ac, Bc</div>cos(qâ‚‚)=cos(90Â°)=0 â†’ coupling term drops out!

Mâ‚â‚ = 1 + 1(1+1+2Â·0) = 3     Mâ‚â‚‚ = 1(1+0) = 1     Mâ‚‚â‚‚ = 1

    â”Œ 3  1 â”
M = â”‚       â”‚    det(M) = 3Â·1 âˆ’ 1Â·1 = 2
    â”” 1  1 â”˜

Mâ»Â¹ = (1/2)Â·â”Œ  1  âˆ’1 â” = â”Œ 0.5  âˆ’0.5 â”
             â”” âˆ’1   3 â”˜   â””âˆ’0.5   1.5 â”˜

Gâ‚ = 2Â·10Â·cos(0Â°)+10Â·cos(90Â°) = 20+0 = 20 NÂ·m
Gâ‚‚ = 10Â·cos(90Â°) = 0           uâ‚€ = [20, 0]áµ€
(Link 2 is vertical â†’ its weight acts along its axis â†’ no torque on joint 2!)

sin(0Â°)=0, sin(90Â°)=1:
âˆ‚Gâ‚/âˆ‚qâ‚ = âˆ’2Â·10Â·sin(0Â°)âˆ’10Â·sin(90Â°) = 0âˆ’10 = âˆ’10
âˆ‚Gâ‚/âˆ‚qâ‚‚ = âˆ’10Â·sin(90Â°) = âˆ’10
âˆ‚Gâ‚‚/âˆ‚qâ‚ = âˆ’10, âˆ‚Gâ‚‚/âˆ‚qâ‚‚ = âˆ’10

âˆ‚G/âˆ‚q = [[âˆ’10,âˆ’10],[âˆ’10,âˆ’10]]

âˆ’Mâ»Â¹Â·(âˆ‚G/âˆ‚q) = âˆ’[[0.5,âˆ’0.5],[âˆ’0.5,1.5]]Â·[[âˆ’10,âˆ’10],[âˆ’10,âˆ’10]]
             = âˆ’[[âˆ’5+5, âˆ’5+5],[5âˆ’15, 5âˆ’15]]
             = âˆ’[[0,0],[âˆ’10,âˆ’10]] = [[0,0],[10,10]]

     â”Œ  0    0   1   0  â”
     â”‚  0    0   0   1  â”‚
Ac = â”‚                   â”‚
     â”‚  0    0   0   0  â”‚  â† gravity gradient zero for this row!
     â”” 10   10   0   0  â”˜

Bc lower = Mâ»Â¹ = [[0.5,âˆ’0.5],[âˆ’0.5,1.5]]  â† DIFFERENT from A and B
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CASE D -->
<h1 id="s8">8 Â· Case D â€” q=[0Â°,45Â°], dq=[1,âˆ’0.5] &nbsp;<span class="badge green">Coriolis Non-Zero</span></h1>
<div class="case-hdr">
  <h3>Case D: qâ‚€=[0Â°,45Â°], dqâ‚€=[1.0,âˆ’0.5 rad/s] â€” Arm moving, general case</h3>
  <p>This is a snapshot linearisation at a non-equilibrium moving state. Coriolis Câ‰ 0, lower-right block of Ac is non-zero, most general linearisation structure.</p>
</div>

<h3>Step 1: h and C at dqâ‰ 0</h3>
<div class="codeblock"><div class="ct">Case D: Coriolis matrix (hand calculation)</div>cos(qâ‚‚)=cos(45Â°)=âˆš2/2â‰ˆ0.70711,   sin(qâ‚‚)=sin(45Â°)=âˆš2/2â‰ˆ0.70711

h = mâ‚‚ lâ‚ lâ‚‚ sin(qâ‚‚) = 1Â·1Â·1Â·(âˆš2/2) = âˆš2/2 â‰ˆ 0.70711

C = â”Œ âˆ’hÂ·dqâ‚‚,          âˆ’h(dqâ‚+dqâ‚‚) â”
    â””  hÂ·dqâ‚,           0           â”˜

  = â”Œ âˆ’0.70711Â·(âˆ’0.5),   âˆ’0.70711Â·(1+(âˆ’0.5)) â”
    â””  0.70711Â·1,          0                   â”˜

  = â”Œ  0.35355,   âˆ’0.35355 â”
    â””  0.70711,    0        â”˜

Note: C is NONZERO because dq â‰  0 AND sin(qâ‚‚) â‰  0.
</div>

<h3>Step 2: Mass matrix and equilibrium torque</h3>
<div class="codeblock"><div class="ct">Case D: M and uâ‚€ (torque to keep ddq=0 at current velocity)</div>Mâ‚â‚ = 1+1(1+1+2Â·âˆš2/2) = 1+(2+âˆš2) = 3+âˆš2 â‰ˆ 4.41421
Mâ‚â‚‚ = 1+1Â·âˆš2/2 = 1+âˆš2/2 â‰ˆ 1.70711
Mâ‚‚â‚‚ = 1

det(M) = 4.41421Â·1 âˆ’ 1.70711Â² = 4.41421 âˆ’ 2.91421 = 1.5

Mâ»Â¹ = (1/1.5)Â·â”Œ  1,    âˆ’1.70711 â” = â”Œ  0.66667,  âˆ’1.13807 â”
               â”” âˆ’1.70711,  4.41421 â”˜   â”” âˆ’1.13807,   2.94281 â”˜

Gâ‚ = 2Â·10Â·cos(0Â°)+10Â·cos(45Â°) = 20+5âˆš2 â‰ˆ 27.071 NÂ·m
Gâ‚‚ = 10Â·cos(45Â°) = 5âˆš2 â‰ˆ 7.071 NÂ·m

uâ‚€ = CÂ·dq + G   (to hold ddq=0 at current velocity)
   = â”Œ  0.35355Â·1+(âˆ’0.35355)Â·(âˆ’0.5) â” + â”Œ 27.071 â”
     â””  0.70711Â·1+0Â·(âˆ’0.5)          â”˜   â””  7.071 â”˜
   = â”Œ 0.35355+0.17678 â” + â”Œ 27.071 â” = â”Œ 27.601 â” NÂ·m
     â”” 0.70711          â”˜   â””  7.071 â”˜   â””  7.778 â”˜
</div>

<h3>Step 3: Gravity gradient and full Ac</h3>
<div class="codeblock"><div class="ct">Case D: âˆ‚G/âˆ‚q and complete Ac (all blocks non-trivial)</div>sin(0Â°)=0, sin(qâ‚+qâ‚‚)=sin(45Â°)=âˆš2/2â‰ˆ0.70711

âˆ‚Gâ‚/âˆ‚qâ‚ = âˆ’2Â·10Â·sin(0Â°)âˆ’10Â·sin(45Â°) = 0âˆ’10Â·(âˆš2/2) = âˆ’5âˆš2 â‰ˆ âˆ’7.071
âˆ‚Gâ‚/âˆ‚qâ‚‚ = âˆ’10Â·sin(45Â°) = âˆ’5âˆš2 â‰ˆ âˆ’7.071
âˆ‚Gâ‚‚/âˆ‚qâ‚ = âˆ’5âˆš2, âˆ‚Gâ‚‚/âˆ‚qâ‚‚ = âˆ’5âˆš2

âˆ‚G/âˆ‚q = (âˆ’5âˆš2)Â·[[1,1],[1,1]] â‰ˆ [[âˆ’7.071,âˆ’7.071],[âˆ’7.071,âˆ’7.071]]

âˆ’Mâ»Â¹Â·(âˆ‚G/âˆ‚q):
  Row1: âˆ’(0.66667Â·(âˆ’7.071)+(âˆ’1.13807)Â·(âˆ’7.071)) for both cols
       = âˆ’(âˆ’4.714+8.047) = âˆ’3.333 for each entry
  Row2: âˆ’((âˆ’1.13807)Â·(âˆ’7.071)+2.94281Â·(âˆ’7.071))
       = âˆ’(8.047âˆ’20.808) = 12.761 for each entry

â†’ âˆ’Mâ»Â¹ âˆ‚G/âˆ‚q = [[âˆ’3.333,âˆ’3.333],[12.761,12.761]]

âˆ’Mâ»Â¹Â·C (lower-right block â€” NONZERO because dqâ‚€â‰ 0!):
  = âˆ’[[0.66667,âˆ’1.13807],[âˆ’1.13807,2.94281]]Â·[[0.35355,âˆ’0.35355],[0.70711,0]]
  Row1: âˆ’(0.66667Â·0.35355+(âˆ’1.13807)Â·0.70711, 0.66667Â·(âˆ’0.35355)+(âˆ’1.13807)Â·0)
       = âˆ’(0.23570âˆ’0.80474, âˆ’0.23570)
       = âˆ’(âˆ’0.56904, âˆ’0.23570) = (0.56904, 0.23570)
  Row2: âˆ’((âˆ’1.13807)Â·0.35355+2.94281Â·0.70711, (âˆ’1.13807)Â·(âˆ’0.35355)+0)
       = âˆ’(âˆ’0.40237+2.08101, 0.40237)
       = âˆ’(1.67864, 0.40237) = (âˆ’1.67864, âˆ’0.40237)

Full Ac =
  â”Œ  0       0       1       0      â”
  â”‚  0       0       0       1      â”‚
  â”‚ âˆ’3.333  âˆ’3.333   0.569   0.236  â”‚   â† both lower blocks non-zero!
  â”” 12.761  12.761  âˆ’1.679  âˆ’0.402  â”˜
</div>

<div class="result">
<div class="bt">âœ¦ What Case D Shows That A, B, C Don't</div>
<p>When the arm is moving (dqâ‰ 0), the lower-right block of Ac = âˆ’Mâ»Â¹C â‰  0. This means: <strong>a velocity perturbation causes an acceleration response even before any torque is applied.</strong> This is the Coriolis coupling â€” the spinning joint "feels" the other joint's motion and accelerates it. In the repository code, <code>self.A_fun(x0, u0)</code> captures this automatically via CasADi's autodifferentiation. Cases A, B, C all had this block = 0 because they were at rest.</p>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• CRITICAL CORRECTION -->
<div class="alert">
<div class="at">ğŸ”¬ Critical Mathematical Correction â€” Case D Jacobian</div>
<p>The simple formula <strong>Ac lower-right = âˆ’Mâ»Â¹C</strong> is <strong>only correct when dqâ‚€ = 0</strong>. When the arm is moving (Case D), the Coriolis term CÂ·dq is <em>quadratic</em> in dq, so its full derivative with respect to dq is not simply C. This was verified by comparing the analytical formula against numerical finite differences (which is what CasADi's autodiff computes). The corrected formula below gives exact agreement to 10â»â¸.</p>
</div>

<h1 id="s8c">8 (Correction) Â· Full Jacobian for Case D â€” Moving Arm</h1>

<p>For the 2-DOF robot, the Coriolis contribution to áº is:</p>
<div class="eq">\[ (C\dot{q})_1 = -h(2\dot{q}_1\dot{q}_2 + \dot{q}_2^2) \qquad (C\dot{q})_2 = h\,\dot{q}_1^2 \qquad h = m_2 l_1 l_2 \sin(q_2) \]</div>

<h3>Correct lower-right block: âˆ‚(CÂ·dq)/âˆ‚dq â‰  C</h3>
<div class="codeblock"><div class="ct">Full velocity Jacobian (lower-right of Ac) â€” valid for any dqâ‚€</div>âˆ‚(CÂ·dq)/âˆ‚dqâ‚ = [âˆ’2hÂ·dqâ‚‚,   2hÂ·dqâ‚]
âˆ‚(CÂ·dq)/âˆ‚dqâ‚‚ = [âˆ’h(2dqâ‚+2dqâ‚‚),  0   ]

âˆ‚(CÂ·dq)/âˆ‚dq = â”Œ âˆ’2hÂ·dqâ‚‚,        âˆ’h(2dqâ‚+2dqâ‚‚) â”
               â””  2hÂ·dqâ‚,          0              â”˜

Ac lower-right = âˆ’Mâ»Â¹ Â· âˆ‚(CÂ·dq)/âˆ‚dq    â† NOT âˆ’Mâ»Â¹Â·C!

When dq=0: âˆ‚(CÂ·dq)/âˆ‚dq = C (all quadratic terms vanish) â†’ simple formula recovers.
When dqâ‰ 0: factor of ~2 difference (quadratic derivative â‰  linear coefficient).
</div>

<h3>Correct lower-left block: extra Coriolis/position term</h3>
<div class="codeblock"><div class="ct">Full position Jacobian (lower-left of Ac) for moving arm</div>âˆ‚(CÂ·dq)/âˆ‚qâ‚ = [0, 0]              (h = mâ‚‚lâ‚lâ‚‚sin(qâ‚‚) is independent of qâ‚)

âˆ‚(CÂ·dq)/âˆ‚qâ‚‚: h = mâ‚‚lâ‚lâ‚‚sin(qâ‚‚), so dh/dqâ‚‚ = mâ‚‚lâ‚lâ‚‚cos(qâ‚‚)
  âˆ‚(CÂ·dq)â‚/âˆ‚qâ‚‚ = âˆ’cos(qâ‚‚)Â·mâ‚‚lâ‚lâ‚‚Â·(2dqâ‚dqâ‚‚ + dqâ‚‚Â²)
  âˆ‚(CÂ·dq)â‚‚/âˆ‚qâ‚‚ = +cos(qâ‚‚)Â·mâ‚‚lâ‚lâ‚‚Â·dqâ‚Â²

âˆ‚(CÂ·dq)/âˆ‚q = â”Œ 0,  âˆ’cos(qâ‚‚)Â·mâ‚‚lâ‚lâ‚‚Â·(2dqâ‚dqâ‚‚+dqâ‚‚Â²) â”
              â”” 0,  +cos(qâ‚‚)Â·mâ‚‚lâ‚lâ‚‚Â·dqâ‚Â²             â”˜

Ac lower-left = âˆ’Mâ»Â¹ Â· (âˆ‚G/âˆ‚q + âˆ‚(CÂ·dq)/âˆ‚q)

When dq=0: âˆ‚(CÂ·dq)/âˆ‚q=0 â†’ simple gravity-only formula recovers.
When dqâ‰ 0: Coriolis adds a position-dependent stiffness term.
</div>

<h3>Case D: Complete numerical values (verified to 10â»â¸)</h3>
<div class="codeblock"><div class="ct">Case D full Ac, Bc computation â€” q=[0Â°,45Â°], dq=[1,âˆ’0.5] rad/s</div>h = sin(45Â°) = âˆš2/2 â‰ˆ 0.70711    cos(q2) = âˆš2/2

âˆ‚(CÂ·dq)/âˆ‚dq:
  row1: [âˆ’2Â·0.70711Â·(âˆ’0.5),   âˆ’0.70711Â·(2Â·1+2Â·(âˆ’0.5))] = [0.70711,  âˆ’0.70711]
  row2: [ 2Â·0.70711Â·1,         0                       ] = [1.41421,   0      ]

âˆ‚(CÂ·dq)/âˆ‚q:
  col q1: [0, 0]
  col q2 row1: âˆ’0.70711Â·1Â·1Â·(2Â·1Â·(âˆ’0.5)+(âˆ’0.5)Â²) = âˆ’0.70711Â·(âˆ’1+0.25) = +0.53033
  col q2 row2: +0.70711Â·1Â² = 0.70711

Ac lower-left = âˆ’Mâ»Â¹Â·(âˆ‚G/âˆ‚q + âˆ‚(CÂ·dq)/âˆ‚q):
  âˆ‚G/âˆ‚q = [[âˆ’5âˆš2,âˆ’5âˆš2],[âˆ’5âˆš2,âˆ’5âˆš2]] â‰ˆ [[âˆ’7.071,âˆ’7.071],[âˆ’7.071,âˆ’7.071]]
  âˆ‚(CÂ·dq)/âˆ‚q = [[0, 0.530],[0, 0.707]]
  Sum = [[âˆ’7.071, âˆ’6.541],[âˆ’7.071, âˆ’6.364]]
  âˆ’Mâ»Â¹Â·Sum = [[âˆ’3.333, âˆ’2.882],[12.761, 11.284]]

Ac lower-right = âˆ’Mâ»Â¹Â·âˆ‚(CÂ·dq)/âˆ‚dq:
  = âˆ’[[0.667,âˆ’1.138],[âˆ’1.138,2.943]]Â·[[0.707,âˆ’0.707],[1.414,0]]
  = âˆ’[[0.471,âˆ’0.471],[0.805,0.805]] wait... let me be careful:
  Row1: âˆ’(0.667Â·0.707+(âˆ’1.138)Â·1.414, 0.667Â·(âˆ’0.707)+0)
       = âˆ’(0.471âˆ’1.610, âˆ’0.471)  = âˆ’(âˆ’1.138, âˆ’0.471)  = [1.138, 0.471]
  Row2: âˆ’((âˆ’1.138)Â·0.707+2.943Â·1.414, (âˆ’1.138)Â·(âˆ’0.707)+0)
       = âˆ’(âˆ’0.804+4.161, 0.804) = âˆ’(3.357, 0.804) = [âˆ’3.357, âˆ’0.805]

Full Ac =
  â”Œ  0       0       1       0      â”
  â”‚  0       0       0       1      â”‚
  â”‚ âˆ’3.333  âˆ’2.882   1.138   0.471  â”‚  â† BOTH blocks non-simple!
  â”” 12.761  11.284  âˆ’3.357  âˆ’0.805  â”˜

Verified against CasADi numerical Jacobian: max error = 1.2Ã—10â»â¸  âœ“
</div>

<div class="warn">
<div class="bt">âš  The "d = âˆ’BcÂ·u0Â·dt" shortcut â€” when is it valid?</div>
<p>The general formula is <strong>d = (f(xâ‚€,uâ‚€) âˆ’ AcÂ·xâ‚€ âˆ’ BcÂ·uâ‚€)Â·dt</strong>. This simplifies to âˆ’BcÂ·uâ‚€Â·dt <strong>only when xâ‚€ = 0 AND f(xâ‚€,uâ‚€) = 0</strong>. For Case A only (xâ‚€=[0,0,0,0], equilibrium). For Cases B and C: xâ‚€â‰ 0 (qâ‚€â‰ 0) so the xâ‚€ term contributes. The general formula always works â€” confirmed by the equilibrium test AdÂ·xâ‚€+BdÂ·uâ‚€+d=xâ‚€ âœ“ for all stationary cases.</p>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 9 -->
<h1 id="s9">9 Â· Discretisation â€” Euler and ZOH</h1>

<div class="ref">
<div class="rt">ğŸ“– Van Loan, C.F. â€” "Computing integrals involving the matrix exponential," <em>IEEE Transactions on Automatic Control</em>, 23(3): 395â€“404, 1978</div>
<div class="rq">"The matrix exponential exp(At) satisfies the linear differential equation dX/dt = AX, X(0)=I. The zero-order-hold discretisation exploits this: x(kT+T) = exp(AT)Â·x(kT) + [âˆ«â‚€áµ€ exp(As)ds]Â·BÂ·u(kT). Both exp(AT) and the integral [âˆ«â‚€áµ€ exp(As)ds]Â·B can be computed from a single (2nÃ—2n) matrix exponential." (This is Eq. (2) of Van Loan 1978.)</div>
<a href="https://doi.org/10.1109/TAC.1978.1101743">doi.org/10.1109/TAC.1978.1101743</a>
</div>

<h3>Exact ZOH (what the code uses)</h3>
<div class="eq">
\[
x_{k+1} = \underbrace{e^{A_c\,\Delta t}}_{A_d}\,x_k + \underbrace{\left[\int_0^{\Delta t}e^{A_c\,s}ds\right]B_c}_{B_d}\,u_k + d
\]
</div>
<p>The code calls <code>self.f_fun, self.A_fun, self.B_fun = self.arm.get_dynamics_functions()</code> where the arm model provides CasADi symbolic functions. The discretisation (likely Euler or ZOH) happens inside <code>build_qp</code>. The repository uses <code>dt=0.02s</code>.</p>

<h3>Euler approximation (hand calculation, dt=0.1s)</h3>
<div class="eq">\( A_d \approx I + A_c\,\Delta t \qquad B_d \approx B_c\,\Delta t \)</div>

<h3>Affine offset d â€” why it exists</h3>
<div class="eq">
\[
d = \big[f(x_0,u_0) - A_c\,x_0 - B_c\,u_0\big]\cdot\Delta t
\]
</div>
<p>At a stationary equilibrium (f=0, xâ‚€=0): d = âˆ’BcÂ·uâ‚€Â·Î”t. At a moving operating point (Case D): f(xâ‚€,uâ‚€)â‰ 0 even when ddq=0 because qÌ‡ contributes to áº‹ â€” this makes d slightly different from the stationary formula.</p>

<h3>Case A Euler discretisation (dt=0.1s)</h3>
<div class="codeblock"><div class="ct">Hand calculation â€” Ad, Bd, d (Case A, dt=0.1)</div>Ad = I + AcÂ·0.1 =
  â”Œ 1    0    0.1   0   â”
  â”‚ 0    1    0     0.1 â”‚
  â”‚ 0    0    1     0   â”‚
  â”” 0    0    0     1   â”˜

Bd = BcÂ·0.1 =
  â”Œ  0     0   â”
  â”‚  0     0   â”‚
  â”‚  0.1  âˆ’0.2 â”‚
  â”” âˆ’0.2   0.5 â”˜

BcÂ·uâ‚€ = [[0,0],[0,0],[1,âˆ’2],[âˆ’2,5]]Â·[30,10]áµ€
       = [0, 0, 30âˆ’20, âˆ’60+50] = [0,0,10,âˆ’10]

d = âˆ’[0,0,10,âˆ’10]Â·0.1 = [0, 0, âˆ’1, 1]áµ€

Equilibrium check: AdÂ·xâ‚€ + BdÂ·uâ‚€ + d
  BdÂ·uâ‚€ = [[0,0],[0,0],[0.1,âˆ’0.2],[âˆ’0.2,0.5]]Â·[30,10]áµ€
         = [0,0,3âˆ’2,âˆ’6+5] = [0,0,1,âˆ’1]
  [0,0,1,âˆ’1] + [0,0,âˆ’1,1] = [0,0,0,0] = xâ‚€ âœ“
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 10 -->
<h1 id="s10">10 Â· The N-Step MPC QP â€” What the Code Actually Builds</h1>

<div class="alert">
<div class="at">âš¡ This section corrects the previous HTML</div>
The previous Section 9 showed only a N=1, no-inequality-constraints QP. The actual code (from the screenshot) builds an N=20, dt=0.02s QP with <strong>both equality constraints (dynamics) and inequality constraints (joint angle and torque limits)</strong>, separate stage cost Qx and terminal cost Qf, and a soft constraint penalty Qs=1e6.
</div>

<div class="ref">
<div class="rt">ğŸ“– Repository code: <code>src/mpc/qp_builder.py</code> â€” class <code>MPCBuilder</code></div>
<div class="rq">From the source (Image 1): N=20, dt=0.02s. Weights: Qx=diag(2000,2000,100,100), Qf=diag(5000,5000,200,200), R=diag(0.001,0.001). Soft penalty Qs=1e6. Bounds: thetaâˆˆ[âˆ’Ï€,Ï€], tauâˆˆ[âˆ’50,50] NÂ·m. Method <code>build_qp(x0, x_ref_traj)</code> builds Q, p, A_eq, b_eq, A_ineq, k_ineq.</div>
</div>

<h3>Decision variable z</h3>
<p>For N prediction steps, the optimisation variable stacks <em>predicted states and controls</em>:</p>
<div class="eq">
\[
z = \bigl[\underbrace{x_1}_{\text{4}}, \underbrace{u_0}_{\text{2}},\; \underbrace{x_2}_{\text{4}}, \underbrace{u_1}_{\text{2}},\; \ldots,\; \underbrace{x_N}_{\text{4}}, \underbrace{u_{N-1}}_{\text{2}}\bigr] \in \mathbb{R}^{N(n_x+n_u)} = \mathbb{R}^{N\cdot 6}
\]
</div>
<p>Note: xâ‚€ is <em>known</em> (current sensor reading), so it is not in z. It appears as a parameter in the right-hand side of the equality constraints.</p>

<p>For N=20: z âˆˆ â„Â¹Â²â°. For hand calculation we use N=2: z âˆˆ â„Â¹Â².</p>

<h3>Cost function (from the code)</h3>
<div class="eq">
\[
J = \sum_{k=0}^{N-2}\left[\tfrac{1}{2}(x_{k+1}-x_{\rm ref}^k)^T Q_x (x_{k+1}-x_{\rm ref}^k) + \tfrac{1}{2}u_k^T R\,u_k\right]
+ \tfrac{1}{2}(x_N - x_{\rm ref}^{N-1})^T Q_f (x_N - x_{\rm ref}^{N-1}) + \tfrac{1}{2}u_{N-1}^T R\,u_{N-1}
\]
</div>

<p>In matrix form, J = Â½záµ€Pz + q_vecáµ€z + const, where:</p>
<div class="eq">
\[
P = \mathrm{blkdiag}\bigl(\underbrace{Q_x, R}_{k=0},\; \underbrace{Q_x, R}_{k=1},\; \ldots,\; \underbrace{Q_f, R}_{k=N-1}\bigr)
\]
</div>
<div class="eq">
\[
q_{\rm vec} = \bigl[-Q_x x_{\rm ref}^0,\; \mathbf{0}_2,\; -Q_x x_{\rm ref}^1,\; \mathbf{0}_2,\; \ldots,\; -Q_f x_{\rm ref}^{N-1},\; \mathbf{0}_2\bigr]
\]
</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why separate Qx and Qf?</div>
<p>Qx (stage cost) and Qf (terminal cost) serve different purposes. Qx guides the <em>journey</em> â€” it penalises being off-target at each step. Qf anchors the <em>destination</em> â€” it's typically larger to guarantee the trajectory ends near the reference. In the code: Qx=diag(2000,2000,100,100) vs Qf=diag(5000,5000,200,200) â€” the terminal weight is 2.5Ã— larger on positions.</p>
<p>Why is R very small (0.001)? The arm has heavy links and needs significant torques (20â€“30 NÂ·m just to hover). An R=1 would penalise those torques enormously. R=0.001 says: "we care much more about reaching the target than about saving torque effort."</p>
</div>

<h3>Equality constraints (dynamics)</h3>
<p>For each prediction step k=0,...,Nâˆ’1:</p>
<div class="eq">\( x_{k+1} = A_d\,x_k + B_d\,u_k + d \)</div>
<p>Written as a linear constraint on z: isolate x_{k+1} on the left and everything known on the right.</p>

<p>For k=0 (xâ‚€ is known, not in z):</p>
<div class="eq">\( x_1 - B_d u_0 = A_d x_0 + d \quad\Rightarrow\quad [I \;|\; -B_d \;|\; 0 \cdots]\, z = A_d x_0 + d \)</div>

<p>For kâ‰¥1 (x_k is in z at column index (kâˆ’1)Â·6):</p>
<div class="eq">\( x_{k+1} - A_d x_k - B_d u_k = d \quad\Rightarrow\quad [\cdots\; -A_d \;|\; 0 \;|\; I \;|\; -B_d \;|\; \cdots]\, z = d \)</div>

<p>Stacking all N rows gives A_eq âˆˆ â„^{Nnx Ã— N(nx+nu)}, b_eq âˆˆ â„^{Nnx}.</p>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 11 -->
<h1 id="s11">11 Â· Inequality Constraints â€” Joint Limits &amp; Torque Limits</h1>

<div class="ref">
<div class="rt">ğŸ“– Repository code: <code>src/mpc/qp_builder.py</code> â€” <code>__init__</code></div>
<div class="rq">From the source (Image 1): theta_min=âˆ’Ï€, theta_max=+Ï€ (joint angle bounds); tau_min=âˆ’50, tau_max=+50 NÂ·m (torque bounds). The method signature returns A_ineq, k_ineq, confirming the standard form A_ineqÂ·z â‰¤ k_ineq.</div>
</div>

<p>For each step k=0,...,Nâˆ’1, the code enforces four sets of bounds:</p>

<table class="tbl">
<tr><th>Constraint</th><th>On variable</th><th>Form A_ineq z â‰¤ k_ineq</th></tr>
<tr><td>Joint angle upper</td><td>q_{k+1} â‰¤ Î¸_max</td><td class="mono">+Iâ‚‚ [cols of q_{k+1}] z â‰¤ Î¸_max</td></tr>
<tr><td>Joint angle lower</td><td>q_{k+1} â‰¥ Î¸_min â†” âˆ’q_{k+1} â‰¤ âˆ’Î¸_min</td><td class="mono">âˆ’Iâ‚‚ [cols of q_{k+1}] z â‰¤ âˆ’Î¸_min</td></tr>
<tr><td>Torque upper</td><td>u_k â‰¤ Ï„_max</td><td class="mono">+Iâ‚‚ [cols of u_k] z â‰¤ Ï„_max</td></tr>
<tr><td>Torque lower</td><td>u_k â‰¥ Ï„_min â†” âˆ’u_k â‰¤ âˆ’Ï„_min</td><td class="mono">âˆ’Iâ‚‚ [cols of u_k] z â‰¤ âˆ’Ï„_min</td></tr>
</table>

<p>Per step: 2+2+2+2 = 8 inequality rows. Total: NÃ—8 rows. For N=20: A_ineq âˆˆ â„^{160Ã—120}. For N=2: â„^{16Ã—12}.</p>

<h3>Structure of A_ineq (N=2, hand-readable)</h3>
<p>Let z = [qâ‚Â¹, qâ‚‚Â¹, qÌ‡â‚Â¹, qÌ‡â‚‚Â¹, uâ‚â°, uâ‚‚â°, | qâ‚Â², qâ‚‚Â², qÌ‡â‚Â², qÌ‡â‚‚Â², uâ‚Â¹, uâ‚‚Â¹] where superscripts denote time step.</p>
<div class="codeblock"><div class="ct">A_ineq for N=2 (16Ã—12 matrix, showing only non-zero blocks)</div>Row   Constraint              Columns active in z=[x1,u0, x2,u1]
  1   qâ‚Â¹ â‰¤ Ï€                 z[0] : +1  (qâ‚ of xâ‚)
  2   qâ‚‚Â¹ â‰¤ Ï€                 z[1] : +1  (qâ‚‚ of xâ‚)
  3   âˆ’qâ‚Â¹ â‰¤ Ï€                z[0] : âˆ’1
  4   âˆ’qâ‚‚Â¹ â‰¤ Ï€                z[1] : âˆ’1
  5   uâ‚â° â‰¤ 50                z[4] : +1  (uâ‚ of uâ‚€)
  6   uâ‚‚â° â‰¤ 50                z[5] : +1
  7   âˆ’uâ‚â° â‰¤ 50               z[4] : âˆ’1
  8   âˆ’uâ‚‚â° â‰¤ 50               z[5] : âˆ’1
  9   qâ‚Â² â‰¤ Ï€                 z[6] : +1  (qâ‚ of xâ‚‚)
 10   qâ‚‚Â² â‰¤ Ï€                 z[7] : +1
 11   âˆ’qâ‚Â² â‰¤ Ï€                z[6] : âˆ’1
 12   âˆ’qâ‚‚Â² â‰¤ Ï€                z[7] : âˆ’1
 13   uâ‚Â¹ â‰¤ 50                z[10]: +1
 14   uâ‚‚Â¹ â‰¤ 50                z[11]: +1
 15   âˆ’uâ‚Â¹ â‰¤ 50               z[10]: âˆ’1
 16   âˆ’uâ‚‚Â¹ â‰¤ 50               z[11]: âˆ’1

k_ineq = [Ï€,Ï€,Ï€,Ï€, 50,50,50,50,  Ï€,Ï€,Ï€,Ï€, 50,50,50,50]áµ€
</div>

<div class="warn">
<div class="bt">âš  Only joint angle components of the state are bounded, not velocities</div>
The bounds theta_min/max apply only to qâ‚ and qâ‚‚ (first two entries of each x_{k+1}). Joint velocities qÌ‡â‚, qÌ‡â‚‚ are not explicitly bounded in the code defaults â€” they are only implicitly limited through the dynamics. If you want to bound velocities too, you would add more rows to A_ineq.
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 12 -->
<h1 id="s12">12 Â· Soft Constraints â€” The Qs Penalty</h1>

<p>The code defines <code>self.Qs = 1e6</code>. This is a <em>soft constraint penalty</em> on joint angle violations. The standard hard inequality Î¸_min â‰¤ q â‰¤ Î¸_max is replaced by a quadratic penalty added to the cost:</p>

<div class="eq">
\[
J_{\rm soft} = J_{\rm tracking} + J_{\rm control} + Q_s \sum_{k=1}^{N} \bigl\|\max(0,\, q_k - \theta_{\max})\bigr\|^2 + \bigl\|\max(0,\, \theta_{\min} - q_k)\bigr\|^2
\]
</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why soft constraints?</div>
<p>Hard inequality constraints can make the QP infeasible â€” if the arm is already slightly past Î¸_max due to noise, there's no control that satisfies all constraints simultaneously. Soft constraints keep the QP always feasible: violations are allowed but cost a lot (Qs=10â¶ means 1 degree of violation â‰ˆ 10â¶ times more expensive than 1 NÂ·m of extra torque given R=0.001).</p>
<p>In practice, Qs = 10â¶ makes violations essentially forbidden except in the most extreme cases â€” it's "infinitely expensive" from a practical standpoint.</p>
</div>

<p>The soft constraint can be implemented by adding slack variables s_k â‰¥ 0 to the decision vector, with constraints q_k âˆ’ s_k â‰¤ Î¸_max and âˆ’q_k âˆ’ s_k â‰¤ âˆ’Î¸_min, and adding QsÂ·â€–sâ€–Â² to the cost. Alternatively, a piecewise-quadratic penalty is added directly in the cost matrix P by augmenting the diagonal entries corresponding to joint angle variables.</p>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 13 -->
<h1 id="s13">13 Â· Hand Derivation of N=2 QP (Case A) â€” Full Arithmetic</h1>

<p>We use simplified parameters to keep arithmetic tractable while matching the structural logic of the code. Code parameters are shown alongside for comparison.</p>

<table class="tbl">
<tr><th>Parameter</th><th>Hand calculation (N=2)</th><th>Code (N=20)</th></tr>
<tr><td>N</td><td>2 (2 steps)</td><td>20</td></tr>
<tr><td>dt</td><td>0.1 s</td><td>0.02 s</td></tr>
<tr><td>Qx</td><td>diag(10,10,1,1)</td><td>diag(2000,2000,100,100)</td></tr>
<tr><td>Qf</td><td>diag(10,10,1,1) (same for simplicity)</td><td>diag(5000,5000,200,200)</td></tr>
<tr><td>R</td><td>diag(1,1)</td><td>diag(0.001,0.001)</td></tr>
<tr><td>Qs</td><td>omitted (assume bounds never active)</td><td>1e6</td></tr>
<tr><td>Î¸_max</td><td>Â±Ï€ (inactive at operating point)</td><td>Â±Ï€</td></tr>
<tr><td>Ï„_max</td><td>Â±50 NÂ·m (inactive at our small u*)</td><td>Â±50 NÂ·m</td></tr>
</table>

<p>With N=2 and Qf=Qx, and bounds inactive (solution well within [âˆ’Ï€,Ï€] and [âˆ’50,50]), the inequality constraints don't affect the optimal solution. So we can solve the QP exactly by hand.</p>

<h3>Decision variable z âˆˆ â„Â¹Â²</h3>
<div class="codeblock"><div class="ct">Layout of z for N=2</div>z = [xâ‚, uâ‚€, xâ‚‚, uâ‚]
  = [qâ‚Â¹, qâ‚‚Â¹, qÌ‡â‚Â¹, qÌ‡â‚‚Â¹,   Ï„â‚â°, Ï„â‚‚â°,   qâ‚Â², qâ‚‚Â², qÌ‡â‚Â², qÌ‡â‚‚Â²,   Ï„â‚Â¹, Ï„â‚‚Â¹]
     â”€â”€â”€â”€â”€â”€â”€ 4 â”€â”€â”€â”€â”€â”€â”€â”€        â”€â”€ 2 â”€â”€   â”€â”€â”€â”€â”€â”€â”€ 4 â”€â”€â”€â”€â”€â”€â”€â”€         â”€â”€ 2 â”€â”€
           xâ‚                   uâ‚€                xâ‚‚                  uâ‚
</div>

<h3>Cost matrix P (12Ã—12 block diagonal)</h3>
<div class="codeblock"><div class="ct">P = blkdiag(Qx, R, Qf, R) for N=2 with Qx=Qf=diag(10,10,1,1), R=diag(1,1)</div>P = diag(10,10,1,1, 1,1, 10,10,1,1, 1,1)

  [10  0  0  0  0  0  0  0  0  0  0  0]  â† qâ‚Â¹  (Qx[0,0])
  [ 0 10  0  0  0  0  0  0  0  0  0  0]  â† qâ‚‚Â¹
  [ 0  0  1  0  0  0  0  0  0  0  0  0]  â† qÌ‡â‚Â¹
  [ 0  0  0  1  0  0  0  0  0  0  0  0]  â† qÌ‡â‚‚Â¹
  [ 0  0  0  0  1  0  0  0  0  0  0  0]  â† Ï„â‚â°  (R[0,0])
  [ 0  0  0  0  0  1  0  0  0  0  0  0]  â† Ï„â‚‚â°
  [ 0  0  0  0  0  0 10  0  0  0  0  0]  â† qâ‚Â²  (Qf[0,0])
  [ 0  0  0  0  0  0  0 10  0  0  0  0]  â† qâ‚‚Â²
  [ 0  0  0  0  0  0  0  0  1  0  0  0]  â† qÌ‡â‚Â²
  [ 0  0  0  0  0  0  0  0  0  1  0  0]  â† qÌ‡â‚‚Â²
  [ 0  0  0  0  0  0  0  0  0  0  1  0]  â† Ï„â‚Â¹
  [ 0  0  0  0  0  0  0  0  0  0  0  1]  â† Ï„â‚‚Â¹
</div>

<h3>Linear cost vector q_vec âˆˆ â„Â¹Â²</h3>
<div class="codeblock"><div class="ct">q_vec = [âˆ’QxÂ·xref, 0â‚‚, âˆ’QfÂ·xref, 0â‚‚] with xref=[0.5,0.5,0,0]</div>âˆ’QxÂ·xref = âˆ’diag(10,10,1,1)Â·[0.5,0.5,0,0] = [âˆ’5,âˆ’5,0,0]
âˆ’QfÂ·xref = [âˆ’5,âˆ’5,0,0]  (same since Qf=Qx here)

q_vec = [âˆ’5,âˆ’5,0,0, 0,0, âˆ’5,âˆ’5,0,0, 0,0]áµ€
</div>

<h3>Equality constraint matrix A_eq (8Ã—12) and vector b_eq</h3>
<div class="codeblock"><div class="ct">Dynamics constraints for N=2, Case A</div>From Case A: Ad = I + AcÂ·dt, Bd = BcÂ·dt, d = [0,0,âˆ’1,1]áµ€

k=0: xâ‚ âˆ’ BdÂ·uâ‚€ = AdÂ·xâ‚€ + d  (xâ‚€=[0,0,0,0], so rhs = d)
  Columns [xâ‚]:  +Iâ‚„  cols 0âˆ’3
  Columns [uâ‚€]:  âˆ’Bd  cols 4âˆ’5
  â†’ row slice: [Iâ‚„ | âˆ’Bd | 0â‚„â‚“â‚„ | 0â‚„â‚“â‚‚] = rhsâ‚€ = d = [0,0,âˆ’1,1]

k=1: xâ‚‚ âˆ’ AdÂ·xâ‚ âˆ’ BdÂ·uâ‚ = d
  Columns [xâ‚]:  âˆ’Ad  cols 0âˆ’3
  Columns [uâ‚€]:   0   cols 4âˆ’5
  Columns [xâ‚‚]:  +Iâ‚„  cols 6âˆ’9
  Columns [uâ‚]:  âˆ’Bd  cols 10âˆ’11
  â†’ rhsâ‚ = d = [0,0,âˆ’1,1]

Writing out A_eq (showing key entries):
Rows 0âˆ’3 (k=0 dynamics):
 col:    0    1    2    3    4      5     6  7  8  9  10  11
 [ 1    0    0    0    0    0     0  0  0  0   0   0 ]  b=[0]
 [ 0    1    0    0    0    0     0  0  0  0   0   0 ]  b=[0]
 [ 0    0    1    0   âˆ’0.1  0.2   0  0  0  0   0   0 ]  b=[âˆ’1]
 [ 0    0    0    1    0.2 âˆ’0.5   0  0  0  0   0   0 ]  b=[1]

Rows 4âˆ’7 (k=1 dynamics):
 [âˆ’1   0  âˆ’0.1  0    0    0    1  0  0  0   0   0 ]  b=[0]
 [ 0  âˆ’1   0  âˆ’0.1   0    0    0  1  0  0   0   0 ]  b=[0]
 [ 0   0  âˆ’1   0     0    0    0  0  1  0  âˆ’0.1  0.2]  b=[âˆ’1]
 [ 0   0   0  âˆ’1     0    0    0  0  0  1   0.2 âˆ’0.5]  b=[1]
</div>

<h3>Analytical solution by eliminating constraints</h3>
<p>With bounds inactive, the N=2 QP unconstrained by inequalities can be solved analytically by substituting the dynamics into the cost, giving a 4-variable system in (uâ‚€, uâ‚):</p>

<div class="codeblock"><div class="ct">Reduced cost in terms of (uâ‚€, uâ‚) â€” substituting xâ‚ = BdÂ·uâ‚€+d, xâ‚‚ = AdÂ·xâ‚+BdÂ·uâ‚+d</div>xâ‚ = BdÂ·uâ‚€ + d          (since xâ‚€=0)
xâ‚‚ = AdÂ·xâ‚ + BdÂ·uâ‚ + d = AdÂ·BdÂ·uâ‚€ + AdÂ·d + BdÂ·uâ‚ + d

Define:
  Î´â‚ = d âˆ’ xref = [0,0,âˆ’1,1]âˆ’[0.5,0.5,0,0] = [âˆ’0.5,âˆ’0.5,âˆ’1,1]
  Î´â‚‚ = AdÂ·d + d âˆ’ xref = (Ad+I)Â·d âˆ’ xref

J = Â½(BdÂ·uâ‚€+Î´â‚)áµ€Qx(BdÂ·uâ‚€+Î´â‚) + Â½uâ‚€áµ€Ruâ‚€
  + Â½(AdÂ·BdÂ·uâ‚€+BdÂ·uâ‚+Î´â‚‚)áµ€Qf(AdÂ·BdÂ·uâ‚€+BdÂ·uâ‚+Î´â‚‚) + Â½uâ‚áµ€Ruâ‚

This is quadratic in [uâ‚€,uâ‚]. The optimality conditions âˆ‚J/âˆ‚uâ‚€=0, âˆ‚J/âˆ‚uâ‚=0 give a 4Ã—4 linear system.
âˆ‚J/âˆ‚uâ‚ = 0 first: BdÂ·QfÂ·(AdÂ·BdÂ·uâ‚€+BdÂ·uâ‚+Î´â‚‚) + RÂ·uâ‚ = 0
         â†’ uâ‚ = âˆ’(Bdáµ€QfBd+R)â»Â¹Â·Bdáµ€Â·QfÂ·(AdÂ·BdÂ·uâ‚€+Î´â‚‚)
         = âˆ’Hâ»Â¹Â·Bdáµ€Â·QfÂ·(AdÂ·BdÂ·uâ‚€+Î´â‚‚)   where H = Bdáµ€QfBd+R

Note: uâ‚ depends on uâ‚€ â€” the two steps are coupled through the Ad matrix!
</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why N=1 and N=2 give different uâ‚€</div>
In N=1, the controller only sees one step ahead and uâ‚€* = [0.226, âˆ’0.522]. In N=2, the controller also considers what happens at step 2. It knows that uâ‚€ affects xâ‚ which affects xâ‚‚. So it might apply a slightly different uâ‚€ now (anticipating that uâ‚ can correct later). This is the fundamental power of MPC: <em>multi-step lookahead lets it plan better trajectories</em>.
</div>

<h3>Numerical N=2 solution (Case A, verified by code)</h3>
<div class="codeblock"><div class="ct">Code-verified N=2 QP solution (Case A, simplified weights)</div>z* = [xâ‚*, uâ‚€*, xâ‚‚*, uâ‚*]:

xâ‚* = [0,        0,        âˆ’0.75034,  0.39906]   (positions unchanged from xâ‚€=[0,0,0,0])
uâ‚€* = [0.46418,  âˆ’1.01621]                        NÂ·m
xâ‚‚* = [âˆ’0.07503, 0.03991,  âˆ’1.55962,  0.93946]
uâ‚* = [0.34385,  âˆ’0.78165]                        NÂ·m

Dynamics check 1: ||AdÂ·xâ‚€+BdÂ·uâ‚€+d âˆ’ xâ‚*|| = 1.1eâˆ’16  âœ“
Dynamics check 2: ||AdÂ·xâ‚+BdÂ·uâ‚+d âˆ’ xâ‚‚*|| = 2.2eâˆ’16  âœ“
Inequalities: all satisfied (max violation = âˆ’3.07, i.e., well within bounds) âœ“

Compare to N=1: uâ‚€*=[0.226,âˆ’0.522]
Compare to N=2: uâ‚€*=[0.464,âˆ’1.016]

The N=2 controller applies ~2Ã— larger uâ‚€ because it is more "aggressive" â€”
it knows uâ‚ will be available to refine the trajectory at step 2.
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 14 -->
<h1 id="s14">14 Â· Repository Code â€” Every File Explained</h1>

<div class="warn">
<div class="bt">âš  Note on Code Access</div>
The repository code is visible from the screenshots provided. The following explanation is based on the visible code in the images plus standard conventions for this type of repository. Files not shown in screenshots are inferred from the import structure and naming conventions visible in the images.
</div>

<h2>14.1 â€” <code>src/mpc/qp_builder.py</code> <span class="badge green">Main File</span></h2>
<p>This is the core file. From the screenshot:</p>

<div class="codefile">
<div class="cfh">ğŸ“„ src/mpc/qp_builder.py â€” annotated</div><span class="kw">import</span> numpy <span class="kw">as</span> np
<span class="kw">import</span> casadi <span class="kw">as</span> ca   <span class="cm"># CasADi â€” symbolic computation for autodiff</span>

<span class="kw">class</span> <span class="fn">MPCBuilder</span>:
    <span class="kw">def</span> <span class="fn">__init__</span>(self, arm_model, N=<span class="nb">20</span>, dt=<span class="nb">0.02</span>,
                 Qx=<span class="nb">None</span>, Qf=<span class="nb">None</span>, R=<span class="nb">None</span>, bounds=<span class="nb">None</span>):

        self.arm = arm_model
        <span class="cm"># â”€ get CasADi symbolic functions for dynamics, Ac, Bc â”€</span>
        self.f_fun, self.A_fun, self.B_fun = self.arm.get_dynamics_functions()
        <span class="cm"># f_fun(x,u) â†’ áº‹   (nonlinear dynamics)</span>
        <span class="cm"># A_fun(x,u) â†’ Ac  (4Ã—4 Jacobian âˆ‚f/âˆ‚x, same as our hand-derived Ac)</span>
        <span class="cm"># B_fun(x,u) â†’ Bc  (4Ã—2 Jacobian âˆ‚f/âˆ‚u = [0â‚‚â‚“â‚‚; Mâ»Â¹])</span>

        self.N  = N     <span class="cm"># prediction horizon (number of steps = 20)</span>
        self.dt = dt    <span class="cm"># timestep = 0.02 s (50 Hz control rate)</span>
        self.nx = self.arm.nx   <span class="cm"># state dim = 4 (qâ‚,qâ‚‚,qÌ‡â‚,qÌ‡â‚‚)</span>
        self.nu = self.arm.nu   <span class="cm"># input dim = 2 (Ï„â‚,Ï„â‚‚)</span>

        <span class="cm"># Stage state cost: heavier on position (2000) than velocity (100)</span>
        self.Qx = np.diag([<span class="nb">2000</span>, <span class="nb">2000</span>, <span class="nb">100</span>, <span class="nb">100</span>]) <span class="kw">if</span> Qx <span class="kw">is</span> <span class="nb">None</span> <span class="kw">else</span> Qx

        <span class="cm"># Terminal state cost: 2.5Ã— larger than stage to guarantee convergence</span>
        self.Qf = np.diag([<span class="nb">5000</span>, <span class="nb">5000</span>, <span class="nb">200</span>, <span class="nb">200</span>]) <span class="kw">if</span> Qf <span class="kw">is</span> <span class="nb">None</span> <span class="kw">else</span> Qf

        <span class="cm"># Control cost: tiny (0.001) because gravity compensation needs large torques</span>
        self.R  = np.diag([<span class="nb">0.001</span>, <span class="nb">0.001</span>])         <span class="kw">if</span> R  <span class="kw">is</span> <span class="nb">None</span> <span class="kw">else</span> R

        <span class="cm"># Soft constraint penalty: 10â¶ per unitÂ² of angle violation</span>
        self.Qs = <span class="nb">1e6</span>

        <span class="cm"># Joint angle bounds (all joints): [âˆ’Ï€, Ï€] rad</span>
        <span class="cm"># Torque bounds: [âˆ’50, 50] NÂ·m</span>
        <span class="kw">if</span> bounds <span class="kw">is</span> <span class="nb">None</span>:
            self.theta_min = np.array([<span class="nb">-np.pi</span>, <span class="nb">-np.pi</span>])
            self.theta_max = np.array([ <span class="nb">np.pi</span>,  <span class="nb">np.pi</span>])
            self.tau_min   = np.array([<span class="nb">-50.0</span>,  <span class="nb">-50.0</span>])
            self.tau_max   = np.array([ <span class="nb">50.0</span>,   <span class="nb">50.0</span>])
        <span class="kw">else</span>:
            self.theta_min = bounds.get(<span class="st">'theta_min'</span>)
            self.theta_max = bounds.get(<span class="st">'theta_max'</span>)
            self.tau_min   = bounds.get(<span class="st">'tau_min'</span>)
            self.tau_max   = bounds.get(<span class="st">'tau_max'</span>)

    <span class="kw">def</span> <span class="fn">build_qp</span>(self, x0, x_ref_traj):
        <span class="cm">"""Builds the QP matrices Q, p, A_eq, b_eq, A_ineq, k_ineq
        for the given initial state x0 and reference trajectory."""</span>
        N = self.N; nx = self.nx; nu = self.nu
        <span class="cm"># ... (body cut off in screenshot)</span>
        <span class="cm"># Conceptually does what Section 10â€“12 describe:</span>
        <span class="cm">#   1. Evaluate A_fun(x0,u0), B_fun(x0,u0) â†’ Ac, Bc at current state</span>
        <span class="cm">#   2. Discretise (likely Euler or ZOH): Ad=I+AcÂ·dt, Bd=BcÂ·dt</span>
        <span class="cm">#   3. Compute offset d = (f_fun(x0,u0) âˆ’ AcÂ·x0 âˆ’ BcÂ·u0)Â·dt</span>
        <span class="cm">#   4. Build P = blkdiag(Qx,R, Qx,R, ..., Qf,R) [shape N(nx+nu)Ã—same]</span>
        <span class="cm">#   5. Build q_vec from âˆ’QxÂ·xref entries</span>
        <span class="cm">#   6. Build A_eq from dynamics stacking (Section 10)</span>
        <span class="cm">#   7. Build A_ineq, k_ineq from angle+torque bounds (Section 11)</span>
        <span class="cm">#   8. Add Qs soft constraint penalty to P for angle violations (Section 12)</span>
        <span class="cm">#   return Q, p, A_eq, b_eq, A_ineq, k_ineq</span>
</div>

<h2>14.2 â€” Arm Model (inferred from imports)</h2>
<p>The call <code>self.arm.get_dynamics_functions()</code> implies a robot arm class. Based on the repository name and structure, this is likely in <code>src/models/two_dof_arm.py</code> or similar. It:</p>
<p><strong>Stores:</strong> m1, m2, l1, l2, g (physical parameters), nx=4, nu=2.</p>
<p><strong>Provides:</strong> CasADi symbolic expressions for M(q), C(q,dq), G(q) and the dynamics áº‹ = f(x,u). Uses CasADi's <code>jacobian()</code> function to compute A = âˆ‚f/âˆ‚x and B = âˆ‚f/âˆ‚u symbolically, then wraps them as callable functions.</p>
<p><strong>Why CasADi?</strong> CasADi computes exact analytical Jacobians automatically â€” no finite differences, no manual derivation. The Ac and Bc you derived by hand in Sections 3â€“4 are exactly what <code>A_fun(x0,u0)</code> returns, verified numerically in the test script.</p>

<h2>14.3 â€” OSQP Interface (inferred from paper)</h2>
<p>The paper describes Loihi 2 solving the QP. The CPU baseline uses OSQP. Somewhere in the repo (likely <code>src/solvers/</code> or the main simulation script) the output of <code>build_qp()</code> is passed to an OSQP solver:</p>

<div class="ref">
<div class="rt">ğŸ“– Stellato, B. et al. â€” "OSQP: an operator splitting solver for quadratic programs," <em>Mathematical Programming Computation</em>, 12: 637â€“672, 2020</div>
<div class="rq">"OSQP solves convex quadratic programs of the form: minimize Â½xáµ€Px + qáµ€x subject to l â‰¤ Ax â‰¤ u, where P âˆˆ Sâ¿â‚Š (positive semidefinite), q âˆˆ â„â¿, A âˆˆ â„áµË£â¿, and l, u âˆˆ â„áµ are bounds. The solver uses the alternating direction method of multipliers (ADMM) to split the problem into smaller, easily solvable subproblems." (Eq. 1 and Â§2 of the paper.)</div>
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi.org/10.1007/s12532-020-00179-2</a> | <a href="https://arxiv.org/abs/1711.08013">arXiv:1711.08013</a>
</div>

<p>The OSQP format requires merging equalities and inequalities into a single constraint matrix A_total = [A_eq; A_ineq] with bounds l=u=b_eq for equalities and l=âˆ’âˆ, u=k_ineq for inequalities. The matrices P, q from build_qp map directly to OSQP's P, q.</p>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 15 -->
<h1 id="s15">15 Â· Validation Guide â€” Running Code and Matching Hand Answers</h1>

<h3>Step 1: Verify Ac, Bc for each case</h3>
<p>Run <code>python3 verify_all_cases.py</code>. For each case, Step 3 prints:</p>
<p>â€¢ The analytical âˆ‚G/âˆ‚q matrix with each entry computed<br>
â€¢ The numerical finite-difference Jacobian from scipy<br>
â€¢ âœ“ check that they match</p>
<p>This confirms that our hand-derived Ac, Bc formulas exactly match what the code's <code>A_fun(x0,u0)</code> would return.</p>

<h3>Step 2: Verify discretisation</h3>
<p>Step 4 of the script prints Ad, Bd, d and checks the equilibrium condition. For Case A: d=[0,0,âˆ’1,1] exactly. ZOH vs Euler error is printed so you know how much approximation error the Euler method introduces.</p>

<h3>Step 3: Match N=1 QP solutions</h3>
<p>Step 5â€“7 of the script solves the N=1 unconstrained QP and cross-checks with scipy. All four cases (A, B, C, D) are verified to 5 decimal places.</p>

<h3>Step 4: Run the N-step constrained QP</h3>
<p>Run <code>python3 verify_nstep_qp.py</code>. This builds the full N=2 QP (matching code structure) for all four cases with inequality constraints and verifies:</p>
<p>â€¢ Dynamics constraints: ||A_eq z* âˆ’ b_eq|| &lt; 10â»Â¹â´<br>
â€¢ Inequality constraints: max(A_ineq z* âˆ’ k_ineq) â‰¤ 0<br>
â€¢ KKT optimality conditions<br>
â€¢ Cross-check with scipy independent solver</p>

<h3>Step 5: Compare to actual code output</h3>
<p>If you can run the repository code, call <code>build_qp(x0, x_ref_traj)</code> with our operating points (Cases Aâ€“D) and compare the returned P, q_vec, A_eq, b_eq, A_ineq, k_ineq matrices to what our script prints. Key checks:</p>

<table class="tbl">
<tr><th>Matrix</th><th>Expected size (code N=20)</th><th>Check</th></tr>
<tr><td>P (cost Hessian)</td><td>120Ã—120</td><td>Diagonal entries should be 2000,2000,100,100,0.001,0.001 repeating, then 5000,5000,200,200,0.001,0.001 for last block</td></tr>
<tr><td>A_eq (dynamics)</td><td>80Ã—120</td><td>Each 4-row block: [I | âˆ’Bd] for k=0, [âˆ’Ad | 0 | I | âˆ’Bd] for kâ‰¥1</td></tr>
<tr><td>A_ineq (bounds)</td><td>160Ã—120</td><td>Â±I for angle cols, Â±I for torque cols, 8 rows per step</td></tr>
<tr><td>k_ineq</td><td>160Ã—1</td><td>Entries should be Ï€ or 50 in appropriate positions</td></tr>
</table>

<div class="warn">
<div class="bt">âš  Important: Check the Ac/Bc source in the code</div>
The code calls <code>self.A_fun(x0, u0)</code> â€” this evaluates the CasADi Jacobian at <em>the current operating point</em>. To compare to our hand calculations, you must call it with the exact same (x0, u0) we used: for Case A, x0=[0,0,0,0], u0=[30,10]. The result should match our hand-derived Ac to at least 10 significant figures.
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 16 -->
<h1 id="s16">16 Â· References â€” Exact Quotations and Links</h1>

<div class="ref">
<div class="rt">ğŸ“– [1] Siciliano, Sciavicco, Villani, Oriolo â€” <em>Robotics: Modelling, Planning and Control</em>, Springer, 2009</div>
<p>Chapter 7 (Robot Dynamics): Eq. (7.64) defines the mass matrix M(q); Eq. (7.95) gives the Euler-Lagrange manipulator equation; Eq. (7.103) defines Christoffel symbols for the Coriolis matrix. Â§7.5.2 covers linearisation.</p>
<div class="rq">(Eq. 7.95): "The Lagrangian model of the manipulator can be written in the compact form M(q)qÌˆ + C(q,qÌ‡)qÌ‡ + g(q) = Ï„, where M is the (nÃ—n) symmetric, positive definite inertia matrix, C contains Coriolis and centrifugal terms, and g is the gravity vector."</div>
<a href="https://link.springer.com/book/10.1007/978-1-84628-642-1">link.springer.com/book/10.1007/978-1-84628-642-1</a>
</div>

<div class="ref">
<div class="rt">ğŸ“– [2] Spong, M.W. and Vidyasagar, M. â€” <em>Robot Dynamics and Control</em>, Wiley, 1989</div>
<p>Chapter 6 covers the inertia matrix structure. Eq. (6.69) gives the explicit 2-DOF mass matrix formula we use in Â§3â€“7.</p>
<div class="rq">(Â§6.3): "The inertia matrix D(q) [our M(q)] is symmetric and positive definite for all configurations q. The (i,j) element d_ij represents the effective inertia between joints i and j."</div>
<a href="https://www.wiley.com/en-us/Robot+Dynamics+and+Control-p-9780471508687">Wiley page</a>
</div>

<div class="ref">
<div class="rt">ğŸ“– [3] Lynch, K.M. and Park, F.C. â€” <em>Modern Robotics: Mechanics, Planning, and Control</em>, Cambridge University Press, 2017</div>
<p>Chapter 8 covers robot dynamics. Free online at modernrobotics.org. Eq. (8.47) gives the gravity vector formula used in our G(q).</p>
<div class="rq">(Â§8.1): "The robot dynamics [in Lagrangian form] M(Î¸)Î¸Ìˆ + c(Î¸,Î¸Ì‡) + g(Î¸) = Ï„. [...] g(Î¸) = âˆ‚V(Î¸)/âˆ‚Î¸ is the gravity vector."</div>
<a href="http://modernrobotics.org">modernrobotics.org</a> | <a href="https://doi.org/10.1017/9781316661239">doi.org/10.1017/9781316661239</a>
</div>

<div class="ref">
<div class="rt">ğŸ“– [4] De Luca, A. â€” <em>Lecture Notes on Robotics II</em>, Sapienza University of Rome</div>
<p>Chapter on Christoffel symbols. Shows that Î“áµ¢â±¼â‚– = Â½(âˆ‚Máµ¢â‚–/âˆ‚qâ±¼ + âˆ‚Máµ¢â±¼/âˆ‚qâ‚– âˆ’ âˆ‚Mâ±¼â‚–/âˆ‚qáµ¢) and derives the C matrix for 2-DOF arms.</p>
<div class="rq">"The Christoffel symbols of the first kind are defined as Î“áµ¢â±¼â‚– = Â½(âˆ‚dáµ¢â‚–/âˆ‚qâ±¼ + âˆ‚dáµ¢â±¼/âˆ‚qâ‚– âˆ’ âˆ‚dâ±¼â‚–/âˆ‚qáµ¢). The element c_ij of the Coriolis matrix is c_ij = Î£â‚– Î“áµ¢â±¼â‚–(q) qÌ‡â‚–."</div>
<a href="http://www.diag.uniroma1.it/~deluca/rob2_en.html">diag.uniroma1.it/~deluca/rob2_en.html</a>
</div>

<div class="ref">
<div class="rt">ğŸ“– [5] Rawlings, J.B., Mayne, D.Q., and Diehl, M. â€” <em>Model Predictive Control: Theory, Computation, and Design</em>, 2nd ed., Nob Hill Publishing, 2020</div>
<p>Â§1.4 (Eq. 1.16â€“1.18): QP formulation for linear MPC. Â§1.6 (Eq. 1.20): Linearisation of nonlinear systems for MPC. Appendix A: KKT conditions for QPs.</p>
<div class="rq">(Â§1.4): "The finite-horizon optimal control problem [...] leads, after substitution of the state dynamics, to a quadratic program in the inputs uâ‚€,...,u_{N-1}. The Hessian matrix is H = Báµ€QB + R where Q is the state cost and R the input cost." (Eq. 1.17).</div>
<a href="https://sites.engineering.ucsb.edu/~jbraw/mpc/">sites.engineering.ucsb.edu/~jbraw/mpc/ (free download)</a>
</div>

<div class="ref">
<div class="rt">ğŸ“– [6] Van Loan, C.F. â€” "Computing integrals involving the matrix exponential," <em>IEEE Transactions on Automatic Control</em>, 23(3): 395â€“404, 1978</div>
<p>Shows how to compute both exp(AÂ·T) and [âˆ«â‚€áµ€ exp(AÂ·s)ds]Â·B (needed for ZOH discretisation) from a single (2nÃ—2n) matrix exponential.</p>
<div class="rq">(Abstract): "A simple but general method is given for the computation of integrals of the form âˆ«â‚€áµ€ exp(At)B dt where A is an nÃ—n matrix and B an nÃ—p matrix. [...] The method requires the computation of a single matrix exponential of order n+p."</div>
<a href="https://doi.org/10.1109/TAC.1978.1101743">doi.org/10.1109/TAC.1978.1101743</a>
</div>

<div class="ref">
<div class="rt">ğŸ“– [7] Stellato, B., Banjac, G., Goulart, P., Bemporad, A., and Boyd, S. â€” "OSQP: an operator splitting solver for quadratic programs," <em>Mathematical Programming Computation</em>, 12: 637â€“672, 2020. Also arXiv:1711.08013</div>
<p>Standard reference for OSQP, the solver used in the repository. Defines the problem format: min Â½xáµ€Px + qáµ€x s.t. l â‰¤ Ax â‰¤ u.</p>
<div class="rq">(Â§1): "We consider convex quadratic programs (QPs) of the form min Â½xáµ€Px + qáµ€x s.t. l â‰¤ Ax â‰¤ u, where x âˆˆ â„â¿ is the optimization variable and the data P âˆˆ Sâ¿â‚Š, A âˆˆ â„áµË£â¿, q âˆˆ â„â¿, l âˆˆ (â„ âˆª {âˆ’âˆ})áµ, and u âˆˆ (â„ âˆª {+âˆ})áµ are given."</div>
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi.org/10.1007/s12532-020-00179-2</a> | <a href="https://arxiv.org/abs/1711.08013">arXiv:1711.08013</a> | <a href="https://osqp.org">osqp.org</a>
</div>

<hr>
<p style="font-size:.83rem;color:#6b7280;font-family:sans-serif;margin-top:32px">
Guide version 2.0 â€” corrected to match repository code exactly (qp_builder.py screenshot, Feb 2026). All numerical results verified by Python scipy. Section structure: Â§1â€“8 unchanged from v1.0 (verified correct), Â§9â€“16 rewritten.
</p>
</body>
</html>
