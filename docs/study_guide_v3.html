<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>2DOF Robot Arm MPC-QP â€” Complete Study Guide v3</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.min.js"></script>
<style>
:root{
  --blue:#1a4f8a;--dblue:#0d2f5c;--lblue:#e8f0fc;--tblue:#c5d8f8;
  --green:#155e36;--lgreen:#dcfce7;--amber:#92400e;--lamber:#fef3c7;
  --red:#7f1d1d;--lred:#fee2e2;--purple:#4c1d95;--lpurp:#f3e8ff;
  --gray:#374151;--lgray:#f9fafb;--border:#d1d5db;
  --mono:'Courier New',monospace;
}
*{box-sizing:border-box;margin:0;padding:0;}
body{font-family:'Georgia',serif;font-size:16px;line-height:1.8;color:var(--gray);
     background:#fff;max-width:980px;margin:0 auto;padding:40px 32px 80px;}
h1{font-size:2rem;color:var(--dblue);border-bottom:3px solid var(--blue);
   padding-bottom:12px;margin-bottom:24px;margin-top:56px;}
h2{font-size:1.42rem;color:var(--blue);border-left:5px solid var(--blue);
   padding-left:14px;margin:40px 0 16px;}
h3{font-size:1.12rem;color:var(--dblue);margin:24px 0 10px;font-style:italic;}
h4{font-size:.92rem;color:#4b5563;margin:16px 0 6px;text-transform:uppercase;
   letter-spacing:.06em;font-family:sans-serif;}
p{margin-bottom:12px;}
strong{color:var(--dblue);}
a{color:var(--blue);}
/* Callout boxes */
.ref{background:var(--lblue);border-left:4px solid var(--blue);border-radius:6px;
     padding:13px 17px;margin:18px 0;font-size:.9rem;font-family:sans-serif;}
.ref .rt{font-weight:700;color:var(--blue);margin-bottom:5px;}
.ref .rq{font-style:italic;color:#374151;margin-top:6px;border-left:2px solid #93bbf5;
         padding-left:10px;font-size:.87rem;}
.intuit{background:var(--lgreen);border-left:4px solid #16a34a;border-radius:6px;
        padding:13px 17px;margin:18px 0;}
.intuit .bt{font-weight:700;color:var(--green);margin-bottom:5px;}
.warn{background:var(--lamber);border-left:4px solid #d97706;border-radius:6px;
      padding:13px 17px;margin:18px 0;}
.warn .bt{font-weight:700;color:var(--amber);margin-bottom:5px;}
.result{background:var(--lpurp);border-left:4px solid #7c3aed;border-radius:6px;
        padding:13px 17px;margin:18px 0;}
.result .bt{font-weight:700;color:var(--purple);margin-bottom:5px;}
.fix{background:#fff1f2;border-left:4px solid #e11d48;border-radius:6px;
     padding:13px 17px;margin:18px 0;}
.fix .bt{font-weight:700;color:#be123c;margin-bottom:5px;}
/* Code blocks */
.cb{background:#f8f8f8;border:1px solid #e5e7eb;border-radius:6px;
    padding:14px 16px;margin:14px 0;font-family:var(--mono);font-size:.82rem;
    line-height:1.9;white-space:pre;overflow-x:auto;}
.cb .ct{font-family:sans-serif;font-weight:700;color:#1f2937;
        margin-bottom:8px;font-size:.88rem;border-bottom:1px solid #e5e7eb;
        padding-bottom:5px;}
.dark{background:#0d1117;color:#c9d1d9;border-radius:8px;padding:16px 20px;
      margin:16px 0;font-family:var(--mono);font-size:.8rem;line-height:1.9;
      white-space:pre;overflow-x:auto;}
.dark .cfh{font-family:sans-serif;font-weight:700;background:#21262d;color:#8b949e;
           padding:4px 10px;border-radius:4px;margin-bottom:12px;
           font-size:.79rem;display:inline-block;}
/* Tables */
.tbl{width:100%;border-collapse:collapse;margin:18px 0;font-size:.86rem;font-family:sans-serif;}
.tbl th{background:var(--blue);color:#fff;padding:8px 12px;text-align:left;}
.tbl td{padding:7px 12px;border-bottom:1px solid var(--border);}
.tbl tr:nth-child(even) td{background:var(--lgray);}
.tbl .mono{font-family:var(--mono);font-size:.8rem;}
/* Case header */
.case-hdr{background:linear-gradient(135deg,var(--dblue),#2563eb);color:#fff;
          border-radius:8px;padding:14px 22px;margin:28px 0 18px;}
.case-hdr h3{color:#fff;font-style:normal;margin:0;font-size:1.15rem;}
.case-hdr p{margin:4px 0 0;opacity:.85;font-size:.88rem;font-family:sans-serif;}
/* TOC */
.toc{background:var(--lgray);border:1px solid var(--border);border-radius:8px;
     padding:18px 26px;margin-bottom:36px;font-family:sans-serif;font-size:.88rem;}
.toc .toc-t{font-weight:700;margin-bottom:8px;color:var(--dblue);}
.toc ol{padding-left:18px;} .toc li{margin:4px 0;}
.toc a{color:var(--blue);text-decoration:none;}
.toc a:hover{text-decoration:underline;}
/* Math */
.eq{overflow-x:auto;padding:14px;text-align:center;font-size:1.02em;margin:12px 0;}
code{background:#f3f4f6;padding:2px 5px;border-radius:3px;
     font-family:var(--mono);font-size:.84em;color:#111;}
hr{border:none;border-top:2px solid var(--border);margin:48px 0;}
.badge{display:inline-block;background:var(--blue);color:#fff;font-family:sans-serif;
       font-size:.73rem;font-weight:700;padding:2px 8px;border-radius:10px;
       vertical-align:middle;margin-left:5px;}
.badge.green{background:#15803d;} .badge.red{background:#b91c1c;}
.badge.amber{background:#b45309;}
.num{display:inline-block;background:var(--blue);color:#fff;font-family:sans-serif;
     font-weight:700;border-radius:50%;width:26px;height:26px;line-height:26px;
     text-align:center;font-size:.82rem;margin-right:7px;flex-shrink:0;}
</style>
</head>
<body>

<h1 style="margin-top:0">2DOF Robot Arm MPC-QP<br>
<span style="font-size:1.05rem;font-weight:400;font-style:italic">
Complete Study Guide v3 â€” Fully aligned with the repository code
</span></h1>

<!-- â•â• CORRECTIONS NOTICE â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="fix">
<div class="bt">âš  8 Critical Corrections vs Study Guide v2 â€” Read First</div>
<p>Every major derivation in v2 was based on a physically different model than the code.
All 8 issues are fixed here; each section cross-references the exact code line that proves it.</p>
<ol style="margin-left:18px;font-family:sans-serif;font-size:.9rem;line-height:2;">
  <li><strong>Mass matrix model:</strong> v2 used point-mass formula (mÂ·lÂ²); code uses
      <strong>uniform-rod inertia</strong> (mÂ·lÂ²/3). Default lengths are lâ‚=lâ‚‚=<strong>0.5 m</strong>, not 1 m.</li>
  <li><strong>Angle convention:</strong> v2 used q=0â†’horizontal with G using cos.
      Code uses q=0â†’<strong>hanging-down</strong> with G using <strong>sin</strong>.</li>
  <li><strong>Case A "double integrator" was wrong:</strong> At q=[0,0] with g=9.81 the gravity gradient
      <em>âˆ‚G/âˆ‚q uses cosines</em> â†’ non-zero â†’ NOT a double integrator.
      True double integrator only when <strong>g=0</strong>.</li>
  <li><strong>z vector excludes xâ‚€:</strong> v2 said z=[xâ‚,uâ‚€,â€¦]. Code has
      <strong>z=[xâ‚€,uâ‚€,xâ‚,uâ‚,â€¦,x_N, sâ‚€,â€¦,s_N]</strong> â€” xâ‚€ IS in z.</li>
  <li><strong>Cost Hessian factor-of-2:</strong> Code stores <strong>2Â·Qx, 2Â·R, 2Â·Qf</strong>
      so OSQP's Â½z<sup>T</sup>Qz equals the Qx-weighted cost. Linear term uses âˆ’2Â·QxÂ·xref.</li>
  <li><strong>Slack variables not documented:</strong> Code appends (N+1)Â·nq slacks.
      Three inequality groups per step: hard torque, soft angleÂ±slack, slackâ‰¥0.</li>
  <li><strong>OSQP wrapping described as "inferred":</strong>
      <code>osqp_solver.py</code> is fully readable; exact mapping shown in Â§7.</li>
  <li><strong>Gravity gradient formula:</strong> v2 derived âˆ‚G/âˆ‚q using sines (matching its
      cos-based G convention). Code's G uses sin â†’ gradient uses <strong>cos â†’ non-zero at q=0</strong>.</li>
</ol>
</div>

<!-- â•â• TOC â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
<div class="toc">
<div class="toc-t">Table of Contents</div>
<ol>
  <li><a href="#s1">Repository Architecture â€” Top-down Map</a></li>
  <li><a href="#s2">Physical Model: Arm2DOF â€” M, C, G with Correct Parameters</a></li>
  <li><a href="#s3">Linearisation â€” Aâ‚“ and Bâ‚“, Block by Block</a></li>
  <li><a href="#s4">Five Canonical Case Studies (Aâ€“E)</a></li>
  <li><a href="#s5">Discretisation â€” Euler and the Affine Offset c_k</a></li>
  <li><a href="#s6">MPC QP Formulation â€” Exact Code Structure</a></li>
  <li><a href="#s7">OSQP Wrapping â€” Exact Mapping</a></li>
  <li><a href="#s8">Hand-Solved N=1 QP â€” Case A (g=0)</a></li>
  <li><a href="#s9">Hand-Solved N=2 QP â€” Case B (g=9.81)</a></li>
  <li><a href="#s10">N=1 with Active Torque Constraint â€” Case C_tight</a></li>
  <li><a href="#s11">Code-Level Walkthrough â€” Every File</a></li>
  <li><a href="#s12">QP Inspector Usage Guide</a></li>
  <li><a href="#s13">Validation Lab Manual â€” Step-by-Step Checklist</a></li>
  <li><a href="#s14">References with Exact Quotations</a></li>
</ol>
</div>
<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 1 -->
<h1 id="s1">1 Â· Repository Architecture</h1>

<p>The simulation loop in <code>src/main.py</code> orchestrates five layers:</p>

<table class="tbl">
<tr><th>Module</th><th>File</th><th>Responsibility</th></tr>
<tr><td><code>Arm2DOF</code></td><td><code>src/dynamics/arm2dof.py</code></td>
    <td>CasADi symbolic M, C, G; autodiff Jacobians; forward integration</td></tr>
<tr><td><code>MPCBuilder</code></td><td><code>src/mpc/qp_builder.py</code></td>
    <td>Reference trajectory; linearise + discretise; assemble Q, p, A_eq, b_eq, A_ineq, k_ineq</td></tr>
<tr><td><code>OSQPSolver</code></td><td><code>src/solver/osqp_solver.py</code></td>
    <td>Wrap 6-tuple into OSQP format (P, q, A, l, u); call solver; return z*</td></tr>
<tr><td><code>QPLogger</code></td><td><code>src/utils/logger.py</code></td>
    <td>Save each step's matrices to <code>.npz</code> for offline inspection</td></tr>
<tr><td><code>ArmAnimator</code></td><td><code>src/utils/visualization.py</code></td>
    <td>Matplotlib animation; forward kinematics for link positions</td></tr>
</table>

<p>At each timestep the loop does: (1) build reference â†’ (2) build QP â†’ (3) log â†’ (4) solve â†’ (5) step dynamics.</p>

<div class="ref">
<div class="rt">Code: <code>src/main.py</code> lines 44â€“97 â€” main simulation loop</div>
<div class="rq">Key lines: <code>x_ref_traj = mpc.build_reference_trajectory(x, x_goal)</code>
â†’ <code>qp_matrices = mpc.build_qp(x, x_ref_traj)</code>
â†’ <code>z = osqp_solver.solve(qp_matrices)</code>
â†’ <code>u_applied = z[arm.nx : arm.nx+arm.nu]</code>
â†’ <code>x = arm.step_dynamics(x, u_applied, dt)</code></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 2 -->
<h1 id="s2">2 Â· Physical Model: Arm2DOF</h1>

<h2>2.1 Angle Convention and Forward Kinematics</h2>

<p><strong>qâ‚=0 means link 1 hangs straight down</strong> (in the âˆ’y direction). This is the gravitational
equilibrium â€” no torque needed to hold position. Forward kinematics confirms this:</p>

<div class="cb"><div class="ct">src/dynamics/arm2dof.py â€” forward_kinematics (lines 90â€“99)</div>x1 =  l1 * sin(q1)       # zero when q1=0 â† link 1 hangs straight down
y1 = -l1 * cos(q1)       # = -l1 when q1=0

x2 = x1 + l2 * sin(q1+q2)
y2 = y1 - l2 * cos(q1+q2)</div>

<div class="warn">
<div class="bt">âš  v2 used the OPPOSITE convention</div>
v2 defined q=0 as horizontal and derived G using <strong>cos(q)</strong>. The code uses <strong>sin(q)</strong>
in the gravity vector. At q=[0,0] the code gives G=[0,0] (hanging equilibrium, no torque needed),
while v2 claimed G=[30,10] NÂ·m. These are physically different robots.
</div>

<h2>2.2 Default Physical Parameters</h2>

<table class="tbl">
<tr><th>Parameter</th><th>Symbol</th><th>Default Value</th><th>v2 (wrong)</th></tr>
<tr><td>Link 1 mass</td><td>mâ‚</td><td><strong>1.0 kg</strong></td><td>1.0 kg</td></tr>
<tr><td>Link 2 mass</td><td>mâ‚‚</td><td><strong>1.0 kg</strong></td><td>1.0 kg</td></tr>
<tr><td>Link 1 length</td><td>lâ‚</td><td><strong>0.5 m</strong></td><td>1.0 m (wrong)</td></tr>
<tr><td>Link 2 length</td><td>lâ‚‚</td><td><strong>0.5 m</strong></td><td>1.0 m (wrong)</td></tr>
<tr><td>Gravity</td><td>g</td><td><strong>9.81 m/sÂ²</strong></td><td>10 m/sÂ² (wrong)</td></tr>
<tr><td>Inertia model</td><td>â€”</td><td><strong>Uniform rod (mlÂ²/3)</strong></td><td>Point mass (mlÂ²) (wrong)</td></tr>
</table>

<h2>2.3 Lagrangian Equations of Motion</h2>

<div class="eq">\[ M(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) = \tau \]</div>

<p>Rearranging for the acceleration (what the code solves):</p>
<div class="eq">\[ \ddot{q} = M^{-1}(q)\bigl[\tau - C(q,\dot{q})\dot{q} - G(q)\bigr] \]</div>

<p>The state is \(x = [q_1, q_2, \dot{q}_1, \dot{q}_2]^\top \in \mathbb{R}^4\), input \(\tau = [Ï„_1, Ï„_2]^\top \in \mathbb{R}^2\).</p>

<h2>2.4 Inertia Matrix M(q) â€” Uniform Rod Formula</h2>

<p>Each link is treated as a <em>uniform rod</em> with moment of inertia mÂ·lÂ²/3 about its proximal end.
This is what <code>arm2dof.py</code> lines 34â€“42 implement:</p>

<div class="eq">
\[
M(q) = \begin{bmatrix}
\frac{m_1 l_1^2}{3} + m_2\!\left(l_1^2 + \frac{l_2^2}{3} + l_1 l_2 \cos q_2\right) &
m_2\!\left(\frac{l_2^2}{3} + \frac{1}{2}l_1 l_2 \cos q_2\right) \\[8pt]
m_2\!\left(\frac{l_2^2}{3} + \frac{1}{2}l_1 l_2 \cos q_2\right) &
\frac{m_2 l_2^2}{3}
\end{bmatrix}
\]
</div>

<p>With default parameters (mâ‚=mâ‚‚=1, lâ‚=lâ‚‚=0.5):</p>

<div class="cb"><div class="ct">M at qâ‚‚=0 (cos qâ‚‚=1) â€” exact fractions and decimals</div>Iâ‚â‚ = mâ‚lâ‚Â²/3 + mâ‚‚(lâ‚Â² + lâ‚‚Â²/3 + lâ‚lâ‚‚Â·1)
     = 1Â·(0.25/3) + 1Â·(0.25 + 0.25/3 + 0.25)
     = 1/12 + 1/4 + 1/12 + 1/4
     = 2/3  â‰ˆ 0.6667

Iâ‚â‚‚ = mâ‚‚(lâ‚‚Â²/3 + Â½Â·lâ‚lâ‚‚Â·1) = 1Â·(1/12 + 1/8) = 5/24  â‰ˆ 0.2083

Iâ‚‚â‚‚ = mâ‚‚lâ‚‚Â²/3 = 1/12  â‰ˆ 0.0833

        â”Œ  2/3   5/24 â”          â”Œ 0.6667  0.2083 â”
M(0) =  â”‚             â”‚   =      â”‚                 â”‚
        â”” 5/24  1/12  â”˜          â”” 0.2083  0.0833 â”˜

det(M) = (2/3)(1/12) âˆ’ (5/24)Â² = 32/576 âˆ’ 25/576 = 7/576 â‰ˆ 0.01215

Mâ»Â¹(0) = (576/7)Â·â”Œ  1/12  âˆ’5/24 â” = â”Œ  48/7  âˆ’120/7 â” = â”Œ  6.857  âˆ’17.143 â”
                  â”” âˆ’5/24   2/3  â”˜   â”” âˆ’120/7  384/7  â”˜   â”” âˆ’17.143   54.857 â”˜

Check: MÂ·Mâ»Â¹ = I  âœ“ (verify with 576/7 * [2/3Â·1/12 âˆ’ 5/24Â·5/24, ...] = [[1,0],[0,1]])</div>

<div class="cb"><div class="ct">M at qâ‚‚=Ï€/2 (cos qâ‚‚=0) â€” coupling drops out</div>Iâ‚â‚ = 1/12 + 1Â·(0.25 + 1/12 + 0) = 1/12 + 1/4 + 1/12 = 5/12 â‰ˆ 0.4167
Iâ‚â‚‚ = 1Â·(1/12 + 0) = 1/12  â‰ˆ 0.0833
Iâ‚‚â‚‚ = 1/12  â‰ˆ 0.0833

        â”Œ 5/12  1/12 â”          det = 5/144 âˆ’ 1/144 = 4/144 = 1/36 â‰ˆ 0.0278
M(Ï€/2)= â”‚             â”‚
        â”” 1/12  1/12 â”˜

Mâ»Â¹(Ï€/2) = 36Â·â”Œ  1/12  âˆ’1/12 â” = â”Œ  3  âˆ’3 â”
               â”” âˆ’1/12   5/12 â”˜   â”” âˆ’3  15 â”˜   â† CLEAN INTEGER MATRIX!</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why does M depend only on qâ‚‚?</div>
M contains lâ‚lâ‚‚cos(qâ‚‚) terms from the parallel-axis theorem â€” the moment of inertia of
link 2 about joint 1 depends on how far link 2's center of mass is from joint 1, which
changes with qâ‚‚ (the elbow angle). qâ‚ only rotates everything rigidly â†’ no change in M.
</div>

<h2>2.5 Coriolis Matrix C(q, qÌ‡)</h2>

<p>Using Christoffel symbols, with \(h = -m_2 l_1 l_2 \sin q_2\):</p>

<div class="eq">
\[
C(q,\dot{q}) = \begin{bmatrix}
h\dot{q}_2 & h(\dot{q}_1 + \dot{q}_2) \\
-h\dot{q}_1 & 0
\end{bmatrix}
\]
</div>

<div class="warn">
<div class="bt">âš  h is NEGATIVE in the code</div>
The code defines <code>h = -m2*l1*l2*ca.sin(th2)</code> (line 46). At qâ‚‚ > 0, h &lt; 0.
At qâ‚‚ = Ï€/4: h = âˆ’0.5Â·0.5Â·0.5Â·sin(Ï€/4) = âˆ’0.25Â·(âˆš2/2) â‰ˆ âˆ’0.1768.
Always substitute this sign before computing CÂ·qÌ‡.
</div>

<h2>2.6 Gravity Vector G(q) â€” Uses sin, Not cos</h2>

<p>Center of mass of each uniform rod is at its midpoint (l/2):</p>

<div class="eq">
\[
G_1(q) = \underbrace{\left(\frac{m_1 l_1}{2} + m_2 l_1\right)}_{\text{=0.75 NÂ·m/rad at g=9.81}}\!g\sin q_1
        + \underbrace{\frac{m_2 l_2}{2}}_{\text{=0.25}}\!g\sin(q_1+q_2)
\]</div>
<div class="eq">
\[
G_2(q) = \frac{m_2 l_2}{2}\,g\sin(q_1+q_2)
\]</div>

<p>At default params: <code>Gâ‚ = 0.75Â·gÂ·sin(qâ‚) + 0.25Â·gÂ·sin(qâ‚+qâ‚‚)</code>, <code>Gâ‚‚ = 0.25Â·gÂ·sin(qâ‚+qâ‚‚)</code>.</p>

<table class="tbl">
<tr><th>Configuration</th><th>Gâ‚ (NÂ·m)</th><th>Gâ‚‚ (NÂ·m)</th><th>u_bar = G</th></tr>
<tr><td>q=[0,0] (hanging down)</td><td>0</td><td>0</td><td>[0, 0]</td></tr>
<tr><td>q=[Ï€/6, 0]</td><td>0.75Â·9.81Â·0.5 + 0.25Â·9.81Â·0.5 = <strong>4.905</strong></td><td>0.25Â·9.81Â·0.5 = <strong>1.226</strong></td><td>[4.905, 1.226]</td></tr>
<tr><td>q=[0, Ï€/2]</td><td>0 + 0.25Â·9.81Â·1 = <strong>2.4525</strong></td><td>0.25Â·9.81Â·1 = <strong>2.4525</strong></td><td>[2.4525, 2.4525]</td></tr>
<tr><td>q=[Ï€/2, 0]</td><td>0.75Â·9.81Â·1 + 0.25Â·9.81Â·1 = <strong>9.81</strong></td><td>0.25Â·9.81Â·1 = <strong>2.4525</strong></td><td>[9.81, 2.4525]</td></tr>
</table>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 3 -->
<h1 id="s3">3 Â· Linearisation â€” Aâ‚“ and Bâ‚“ Block by Block</h1>

<p>The full nonlinear dynamics are \(\dot{x} = f(x,u)\). Around an operating point
\((\bar{x}, \bar{u})\) the first-order Taylor expansion gives:</p>

<div class="eq">\[
\dot{x} \approx f(\bar{x},\bar{u})
+ \underbrace{\frac{\partial f}{\partial x}\bigg|_{\bar{x},\bar{u}}}_{A_c}(x - \bar{x})
+ \underbrace{\frac{\partial f}{\partial u}\bigg|_{\bar{x},\bar{u}}}_{B_c}(u - \bar{u})
\]</div>

<p>The code evaluates these Jacobians via CasADi automatic differentiation:
<code>A_fun(x_bar, u_bar)</code> and <code>B_fun(x_bar, u_bar)</code>.</p>

<h2>3.1 Block Structure of Aâ‚“</h2>

<p>With state \(x=[q_1, q_2, \dot{q}_1, \dot{q}_2]^\top\), the dynamics split into:</p>
<div class="eq">\[
A_c = \frac{\partial f}{\partial x} = \begin{bmatrix}
\mathbf{0}_{2\times2} & \mathbf{I}_{2\times2} \\[6pt]
-M^{-1}\!\left(\frac{\partial G}{\partial q} + \frac{\partial (C\dot{q})}{\partial q}\right) &
-M^{-1}\frac{\partial (C\dot{q})}{\partial \dot{q}}
\end{bmatrix}
\]</div>

<table class="tbl">
<tr><th>Block</th><th>Formula</th><th>When is it non-zero?</th></tr>
<tr><td>Upper-left (âˆ‚qÌ‡/âˆ‚q)</td><td>0</td><td>Never â€” position doesn't affect velocity eq.</td></tr>
<tr><td>Upper-right (âˆ‚qÌ‡/âˆ‚qÌ‡)</td><td>I</td><td>Always â€” kinematic identity</td></tr>
<tr><td>Lower-left (âˆ‚qÌˆ/âˆ‚q)</td><td>âˆ’Mâ»Â¹(âˆ‚G/âˆ‚q + âˆ‚(CqÌ‡)/âˆ‚q)</td><td>Whenever gâ‰ 0 (gravity gradient) OR qÌ‡â‰ 0 (Coriolis position-coupling)</td></tr>
<tr><td>Lower-right (âˆ‚qÌˆ/âˆ‚qÌ‡)</td><td>âˆ’Mâ»Â¹Â·âˆ‚(CqÌ‡)/âˆ‚qÌ‡</td><td>Only when qÌ‡â‰ 0 (Coriolis velocity coupling)</td></tr>
</table>

<h2>3.2 Gravity Gradient âˆ‚G/âˆ‚q â€” Uses COSINES</h2>

<p>Because G uses sin, its gradient uses cos. At any configuration:</p>

<div class="eq">
\[
\frac{\partial G}{\partial q} = \begin{bmatrix}
\left(\tfrac{m_1 l_1}{2}+m_2 l_1\right)g\cos q_1 + \tfrac{m_2 l_2}{2}g\cos(q_1+q_2) &
\tfrac{m_2 l_2}{2}g\cos(q_1+q_2) \\[6pt]
\tfrac{m_2 l_2}{2}g\cos(q_1+q_2) &
\tfrac{m_2 l_2}{2}g\cos(q_1+q_2)
\end{bmatrix}
\]
</div>

<p>At default params: define \(\alpha_1 = 0.75g\cos q_1 + 0.25g\cos(q_1+q_2)\) and
\(\alpha_2 = 0.25g\cos(q_1+q_2)\). Then:</p>
<div class="eq">\[\frac{\partial G}{\partial q} = \begin{bmatrix}\alpha_1 & \alpha_2 \\ \alpha_2 & \alpha_2\end{bmatrix}\]</div>

<div class="fix">
<div class="bt">KEY CORRECTION: gravity gradient at q=[0,0] is NOT zero</div>
<p>At q=[0,0]: cos(0)=1 â†’ Î±â‚ = 0.75Â·9.81 + 0.25Â·9.81 = <strong>9.81</strong>, Î±â‚‚ = 0.25Â·9.81 = <strong>2.4525</strong>.</p>
<p>âˆ‚G/âˆ‚q = [[9.81, 2.4525],[2.4525, 2.4525]] â€” <strong>strongly non-zero</strong>.</p>
<p>v2 claimed it was zero because v2 used G(cos) â†’ âˆ‚G/âˆ‚q(sin) â†’ zero at q=0. The code uses G(sin) â†’ âˆ‚G/âˆ‚q(cos) â†’ non-zero at q=0.</p>
</div>

<h2>3.3 Coriolis Velocity Jacobian â€” âˆ‚(CqÌ‡)/âˆ‚qÌ‡ â‰  C when qÌ‡â‰ 0</h2>

<p>The velocity-dependent accelerations are quadratic in qÌ‡. With
\(h = -m_2 l_1 l_2 \sin q_2\):</p>

<div class="eq">\[
(C\dot{q})_1 = h(2\dot{q}_1\dot{q}_2 + \dot{q}_2^2), \qquad
(C\dot{q})_2 = -h\dot{q}_1^2
\]</div>

<div class="eq">\[
\frac{\partial(C\dot{q})}{\partial \dot{q}} = \begin{bmatrix}
2h\dot{q}_2 & h(2\dot{q}_1+2\dot{q}_2) \\
-2h\dot{q}_1 & 0
\end{bmatrix}
\]</div>

<p>When qÌ‡=0 all entries are zero â†’ lower-right of Aâ‚“ = 0. This is why the code's
<code>MPCBuilder.build_qp</code> linearizes around the <em>reference trajectory</em>
(which always has qÌ‡_ref=0) â€” the Coriolis velocity block is always zero in the QP.</p>

<h2>3.4 Bâ‚“ â€” Input Jacobian</h2>

<p>Torque Ï„ appears only in the acceleration equation:</p>
<div class="eq">\[
B_c = \frac{\partial f}{\partial u} = \begin{bmatrix}\mathbf{0}_{2\times2} \\ M^{-1}(q)\end{bmatrix}
\]</div>

<p>Bâ‚“ changes with configuration only because M(q) depends on qâ‚‚ (via cos qâ‚‚). Position and
velocity rows of f are independent of Ï„ â†’ top half is always zero.</p>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 4 -->
<h1 id="s4">4 Â· Five Canonical Case Studies</h1>

<p>All cases use default parameters (mâ‚=mâ‚‚=1, lâ‚=lâ‚‚=0.5, dt=0.1s) unless noted.
Reproduce any case with <code>python3 src/utils/qp_inspector.py --case X --linearise</code>.</p>

<!-- â”€â”€ CASE A â”€â”€ -->
<div class="case-hdr">
  <h3>Case A: g=0, q=[0,0], qÌ‡=[0,0] â€” True Pure Double Integrator</h3>
  <p>Gravity off. G=0, âˆ‚G/âˆ‚q=0, C=0. Aâ‚“ is the pure kinematic double integrator.</p>
</div>

<div class="cb"><div class="ct">Case A â€” M, Aâ‚“, Bâ‚“, Aáµˆ, Báµˆ, c_k (verified by qp_inspector)</div>M: same as qâ‚‚=0 block above
Mâ»Â¹ = [[48/7, -120/7],[-120/7, 384/7]] â‰ˆ [[6.857, -17.143],[-17.143, 54.857]]

G = [0, 0]    (g=0)    u_bar = [0, 0]    âˆ‚G/âˆ‚q = [[0,0],[0,0]]    C = 0

     â”Œ 0  0  1  0 â”
Aâ‚“ = â”‚ 0  0  0  1 â”‚   â† PURE DOUBLE INTEGRATOR (all lower blocks = 0)
     â”‚ 0  0  0  0 â”‚
     â”” 0  0  0  0 â”˜

     â”Œ  0      0    â”
     â”‚  0      0    â”‚
Bâ‚“ = â”‚               â”‚  = [0â‚‚â‚“â‚‚ ; Mâ»Â¹]
     â”‚  6.857  -17.143â”‚
     â”” -17.143  54.857â”˜

dt = 0.1s:
     â”Œ 1  0  0.1   0  â”           â”Œ  0      0    â”
     â”‚ 0  1   0   0.1  â”‚           â”‚  0      0    â”‚
Aáµˆ = â”‚                  â”‚    Báµˆ =  â”‚  0.686  -1.714â”‚
     â”‚ 0  0   1    0   â”‚           â”” -1.714   5.486â”˜
     â”” 0  0   0    1   â”˜

c_k = [0, 0, 0, 0]   (f=0, Aâ‚“Â·xÌ„=0, Bâ‚“Â·Å«=0 at origin with g=0)</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why is g=0 needed for double integrator, not q=[0,0]?</div>
At q=[0,0] with g=9.81 the gradient âˆ‚G/âˆ‚q = [[9.81,2.45],[2.45,2.45]] â‰  0.
This means a small position perturbation creates an acceleration via gravity â†’ position feedback
â†’ NOT a pure integrator. Setting g=0 removes all gravity coupling.
</div>

<!-- â”€â”€ CASE B â”€â”€ -->
<div class="case-hdr">
  <h3>Case B: g=9.81, q=[0,0], qÌ‡=[0,0] â€” Hanging Equilibrium</h3>
  <p>G=0 (no torque needed) but âˆ‚G/âˆ‚q â‰  0 (gravity acts as position-dependent stiffness). c_k=0.</p>
</div>

<div class="cb"><div class="ct">Case B â€” gravity gradient and Aâ‚“ (verified by qp_inspector --case B --linearise)</div>G = [0, 0]    u_bar = [0, 0]    (links hang down, gravity balanced without torque)

âˆ‚G/âˆ‚q at q=[0,0]:
  Î±â‚ = 0.75Â·9.81Â·cos(0) + 0.25Â·9.81Â·cos(0) = 0.75Â·9.81 + 0.25Â·9.81 = 9.81
  Î±â‚‚ = 0.25Â·9.81Â·cos(0) = 2.4525

  âˆ‚G/âˆ‚q = [[9.81, 2.4525],[2.4525, 2.4525]]

-Mâ»Â¹Â·(âˆ‚G/âˆ‚q):
  Row 0: -(48/7Â·9.81 + (-120/7)Â·2.4525, 48/7Â·2.4525 + (-120/7)Â·2.4525)
       = -(176.58/7, -176.58/7)      = (-25.226, 25.226)
  Row 1: -((-120/7)Â·9.81 + (384/7)Â·2.4525, (-120/7)Â·2.4525 + (384/7)Â·2.4525)
       = -(-235.44/7, 647.46/7)      = (33.634, -92.494)

Aâ‚“_B = [[  0,       0,      1,   0  ],
         [  0,       0,      0,   1  ],
         [-25.226,  25.226,  0,   0  ],   â† gravity stiffness active!
         [ 33.634, -92.494,  0,   0  ]]

Aáµˆ (dt=0.1) = I + 0.1Â·Aâ‚“:
  Row 2: [-2.523,  2.523, 1, 0]
  Row 3: [ 3.363, -9.249, 0, 1]

c_k = [0, 0, 0, 0]   (xÌ„=[0,0,0,0], u_bar=0 â†’ all terms zero)</div>

<!-- â”€â”€ CASE C â”€â”€ -->
<div class="case-hdr">
  <h3>Case C: g=9.81, q=[Ï€/6,0], qÌ‡=[0,0] â€” Gravity Torque Active</h3>
  <p>Gâ‰ 0, u_bar=G=[4.905,1.226]. Same M (qâ‚‚=0). Gradient scaled by cos(Ï€/6)=âˆš3/2. c_kâ‰ 0.</p>
</div>

<div class="cb"><div class="ct">Case C â€” G, u_bar, âˆ‚G/âˆ‚q, c_k (code: qp_inspector --case C --linearise)</div>Gâ‚ = 0.75Â·9.81Â·sin(Ï€/6) + 0.25Â·9.81Â·sin(Ï€/6) = 9.81Â·0.5 = 4.905 NÂ·m
Gâ‚‚ = 0.25Â·9.81Â·sin(Ï€/6) = 0.25Â·9.81Â·0.5 = 1.226 NÂ·m
u_bar = [4.905, 1.226]

âˆ‚G/âˆ‚q at q=[Ï€/6,0]:
  Î±â‚ = 0.75Â·9.81Â·cos(Ï€/6) + 0.25Â·9.81Â·cos(Ï€/6) = 9.81Â·(âˆš3/2) â‰ˆ 8.496
  Î±â‚‚ = 0.25Â·9.81Â·cos(Ï€/6) â‰ˆ 2.124

  âˆ‚G/âˆ‚q â‰ˆ [[8.496, 2.124],[2.124, 2.124]] = (âˆš3/2)Â·[[9.81, 2.4525],[2.4525, 2.4525]]

-Mâ»Â¹Â·(âˆ‚G/âˆ‚q) â‰ˆ (âˆš3/2)Â·[[-25.226, 25.226],[33.634, -92.494]]
              â‰ˆ [[-21.846, 21.846],[29.128, -80.102]]

Aâ‚“_C = [[  0,        0,      1,  0],
         [  0,        0,      0,  1],
         [-21.846,  21.846,   0,  0],
         [ 29.128, -80.102,   0,  0]]

c_k = dtÂ·(f âˆ’ Aâ‚“Â·xÌ„ âˆ’ Bâ‚“Â·u_bar)
    = 0.1Â·(0 âˆ’ Aâ‚“Â·[Ï€/6,0,0,0] âˆ’ Bâ‚“Â·[4.905,1.226])

Aâ‚“Â·xÌ„: rows 0-1 = 0; row 2 = -21.846Â·(Ï€/6) â‰ˆ -11.44; row 3 = 29.128Â·(Ï€/6) â‰ˆ 15.26
Bâ‚“Â·uÌ…: rows 0-1 = 0; row 2 = 6.857Â·4.905âˆ’17.143Â·1.226 â‰ˆ 12.61; row 3 â‰ˆ -16.82

c_k â‰ˆ 0.1Â·[0, 0, âˆ’(âˆ’11.44+12.61), âˆ’(15.26âˆ’16.82)]
     = [0, 0, âˆ’0.117, 0.157]</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why is c_k non-zero in Case C but zero in Cases A and B?</div>
c_k = dtÂ·(f âˆ’ Aâ‚“Â·xÌ„ âˆ’ Bâ‚“Â·Å«). In Cases A and B, xÌ„=[0,0,0,0] so Aâ‚“Â·xÌ„=0.
In Case C, xÌ„=[Ï€/6,0,0,0] â‰  0 and Aâ‚“ has non-zero lower-left blocks, so Aâ‚“Â·xÌ„â‰ 0.
c_k ensures the linearised model is consistent at the operating point.
Equilibrium check always holds: AáµˆÂ·xÌ„ + BáµˆÂ·Å« + c_k = xÌ„ âœ“
</div>

<!-- â”€â”€ CASE D â”€â”€ -->
<div class="case-hdr">
  <h3>Case D: g=9.81, q=[0,Ï€/2], qÌ‡=[0,0] â€” cos(qâ‚‚)=0, M and Bâ‚“ change</h3>
  <p>cos(Ï€/2)=0 â†’ M decoupled. Clean Mâ»Â¹=[[3,-3],[-3,15]]. Only qâ‚-row has non-zero gradient.</p>
</div>

<div class="cb"><div class="ct">Case D â€” Mâ»Â¹=[[3,-3],[-3,15]], G, âˆ‚G/âˆ‚q, Aâ‚“, c_k</div>M at qâ‚‚=Ï€/2: [[5/12, 1/12],[1/12,1/12]]   Mâ»Â¹ = [[3,-3],[-3,15]]

Gâ‚ = 0.75Â·9.81Â·sin(0) + 0.25Â·9.81Â·sin(Ï€/2) = 0 + 2.4525 = 2.4525 NÂ·m
Gâ‚‚ = 0.25Â·9.81Â·sin(Ï€/2) = 2.4525 NÂ·m
u_bar = [2.4525, 2.4525]

âˆ‚G/âˆ‚q at q=[0,Ï€/2]:  cos(qâ‚+qâ‚‚)=cos(Ï€/2)=0
  Î±â‚ = 0.75Â·9.81Â·cos(0) + 0 = 7.3575
  Î±â‚‚ = 0.25Â·9.81Â·cos(Ï€/2) = 0

  âˆ‚G/âˆ‚q = [[7.3575,  0],
            [0,       0]]   â† only (0,0) entry is non-zero!

-Mâ»Â¹Â·(âˆ‚G/âˆ‚q) = -[[3,-3],[-3,15]]Â·[[7.3575,0],[0,0]]
              = -[[3Â·7.3575, 0],[-3Â·7.3575, 0]]
              = [[-22.073, 0],[22.073, 0]]

Aâ‚“_D = [[ 0,       0,  1,  0],
         [ 0,       0,  0,  1],
         [-22.073,  0,  0,  0],   â† only qâ‚ coupling
         [ 22.073,  0,  0,  0]]

Bâ‚“_D = [[0, 0],[0, 0],[3,-3],[-3,15]]  â† DIFFERENT from Cases A/B/C!

c_k = dtÂ·(0 âˆ’ Aâ‚“Â·[0,Ï€/2,0,0] âˆ’ Bâ‚“Â·[2.4525,2.4525])
Aâ‚“Â·xÌ„: rows 0-1=0; row 2=-22.073Â·0+0Â·(Ï€/2)=0; row 3=22.073Â·0+0Â·(Ï€/2)=0
Bâ‚“Â·Å«: rows 0-1=0; row 2=(3âˆ’3)Â·2.4525=0; row 3=(âˆ’3+15)Â·2.4525=29.43
c_k = [0, 0, 0, 0.1Â·(0âˆ’29.43)] = [0, 0, 0, âˆ’2.943]</div>

<!-- â”€â”€ CASE E â”€â”€ -->
<div class="case-hdr">
  <h3>Case E: g=9.81, q=[0,Ï€/4], qÌ‡=[1,âˆ’0.5] â€” Full General (Coriolis active)</h3>
  <p>All Aâ‚“ blocks non-zero. hâ‰ 0 and qÌ‡â‰ 0 â†’ lower-right Coriolis block â‰  0.
  NOTE: the code always linearises around qÌ‡_ref=0, so this block = 0 in MPCBuilder.</p>
</div>

<div class="cb"><div class="ct">Case E â€” full Aâ‚“ at moving operating point (qp_inspector.print_case_e_full())</div>qÌ„=[0, Ï€/4],  qÌ‡Ì„=[1, -0.5],  g=9.81

h = -mâ‚‚lâ‚lâ‚‚sin(qâ‚‚) = -0.25Â·sin(Ï€/4) = -0.1768

CÂ·qÌ‡ (using quadratic formulas):
  (CqÌ‡)â‚ = hÂ·(2qÌ‡â‚qÌ‡â‚‚ + qÌ‡â‚‚Â²) = -0.1768Â·(2Â·1Â·(-0.5)+0.25) = -0.1768Â·(-0.75) = 0.1326
  (CqÌ‡)â‚‚ = -hÂ·qÌ‡â‚Â² = 0.1768Â·1 = 0.1768

u_bar = CqÌ‡ + G = [0.1326+1.734, 0.1768+1.734] = [1.867, 1.911] NÂ·m

f(xÌ„,Å«) = [qÌ‡â‚, qÌ‡â‚‚, 0, 0] = [1, -0.5, 0, 0]  â† non-zero! (f = áº‹ at snapshot)

âˆ‚(CqÌ‡)/âˆ‚qÌ‡ (full velocity Jacobian, non-zero when qÌ‡â‰ 0):
  âˆ‚(CqÌ‡)â‚/âˆ‚qÌ‡â‚ = 2hÂ·qÌ‡â‚‚ = -0.1768Â·2Â·(-0.5) = 0.1768
  âˆ‚(CqÌ‡)â‚/âˆ‚qÌ‡â‚‚ = hÂ·(2qÌ‡â‚+2qÌ‡â‚‚) = -0.1768Â·(2-1) = -0.1768
  âˆ‚(CqÌ‡)â‚‚/âˆ‚qÌ‡â‚ = -2hÂ·qÌ‡â‚ = 0.3536,   âˆ‚(CqÌ‡)â‚‚/âˆ‚qÌ‡â‚‚ = 0

Full Aâ‚“ (verified against CasADi autodiff):
  â”Œ   0        0       1      0    â”
  â”‚   0        0       0      1    â”‚
  â”‚ -23.032   8.644   2.303  0.738 â”‚  â† lower-right â‰  0! (Coriolis)
  â””  26.651 -40.745  -8.988 -1.520 â”˜

âš  Code note: MPCBuilder always uses x_ref_traj[k] which has qÌ‡=0.
  â†’ lower-right block is always 0 in QPs built by MPCBuilder.
  â†’ Coriolis is treated as an unmodelled nonlinearity, compensated by MPC receding horizon.</div>

<div class="ref">
<div class="rt">Code: <code>src/utils/qp_inspector.py</code> â€” <code>print_case_e_full()</code></div>
<div class="rq">Call <code>from src.utils.qp_inspector import print_case_e_full; print_case_e_full()</code>
to reproduce all Case E numbers, verified against CasADi's autodiff Jacobian to machine precision.</div>
</div>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 5 -->
<h1 id="s5">5 Â· Discretisation â€” Euler and the Affine Offset c_k</h1>

<p>The code uses <strong>first-order Euler discretisation</strong> (matching <code>build_qp</code> lines 112â€“114):</p>

<div class="eq">
\[
A_d = I + \Delta t \, A_c, \qquad
B_d = \Delta t \, B_c, \qquad
c_k = \Delta t\bigl(f(\bar{x},\bar{u}) - A_c\bar{x} - B_c\bar{u}\bigr)
\]
</div>

<p>The discrete-time dynamics are then:</p>
<div class="eq">\[ x_{k+1} = A_d\,x_k + B_d\,u_k + c_k \]</div>

<h2>5.1 The Affine Offset c_k â€” Why It Exists and What It Does</h2>

<div class="intuit">
<div class="bt">ğŸ’¡ Intuition for c_k</div>
<p>The linearisation says: áº‹ â‰ˆ f(xÌ„,Å«) + Aâ‚“(xâˆ’xÌ„) + Bâ‚“(uâˆ’Å«). Rearranging:
áº‹ â‰ˆ Aâ‚“x + Bâ‚“u + [f(xÌ„,Å«) âˆ’ Aâ‚“xÌ„ âˆ’ Bâ‚“Å«].</p>
<p>The bracket is c_k/dt. It is the "residual" that makes the linear model go through the operating point. Without it, the linearised model would predict áº‹=0 when x=xÌ„, u=Å« â€” which is only true at equilibrium (f=0).</p>
<p><strong>Equilibrium check:</strong> If xÌ„ is a static equilibrium (f=0, u=G), then
AáµˆÂ·xÌ„ + BáµˆÂ·Å« + c_k = xÌ„ always holds (verified for all cases above). âœ“</p>
</div>

<table class="tbl">
<tr><th>Case</th><th>c_k (dt=0.1s)</th><th>Why</th></tr>
<tr><td>A (g=0, q=[0,0])</td><td>[0, 0, 0, 0]</td><td>xÌ„=0, uÌ…=0, f=0 â†’ all zero</td></tr>
<tr><td>B (g=9.81, q=[0,0])</td><td>[0, 0, 0, 0]</td><td>xÌ„=0, uÌ…=0, f=0 â†’ all zero</td></tr>
<tr><td>C (g=9.81, q=[Ï€/6,0])</td><td>[0, 0, âˆ’0.117, 0.157]</td><td>xÌ„â‰ 0 â†’ Aâ‚“Â·xÌ„â‰ 0</td></tr>
<tr><td>D (g=9.81, q=[0,Ï€/2])</td><td>[0, 0, 0, âˆ’2.943]</td><td>Bâ‚“Â·Å« has non-zero row 3</td></tr>
<tr><td>E (moving arm)</td><td>[0, 0, âˆ’0.008, âˆ’0.052]</td><td>fâ‰ 0 (velocity part) + xÌ„â‰ 0</td></tr>
</table>

<h2>5.2 ZOH Reference (more accurate, not used in code)</h2>

<div class="eq">\[
A_d^{\rm ZOH} = e^{A_c \Delta t}, \qquad
B_d^{\rm ZOH} = \left[\int_0^{\Delta t} e^{A_c s}\,ds\right] B_c
\]</div>

<p>For small dt (dt=0.02s default) the Euler error is O(dtÂ²) â‰ˆ 4Ã—10â»â´, acceptable for real-time MPC.
For hand calculations using dt=0.1s the Euler error is larger but the structure is much cleaner.</p>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 6 -->
<h1 id="s6">6 Â· MPC QP Formulation â€” Exact Code Structure</h1>

<h2>6.1 Decision Variable z â€” With xâ‚€ and Slacks</h2>

<div class="fix">
<div class="bt">KEY CORRECTION: z includes xâ‚€</div>
<p>v2 said z=[xâ‚,uâ‚€,xâ‚‚,uâ‚,â€¦]. The code computes
<code>n_z = N*(nx+nu) + nx</code> (line 43) which includes xâ‚€ through x_N.
xâ‚€ is not "known and excluded" â€” it is a decision variable pinned by an equality row.</p>
</div>

<div class="eq">
\[
z = \underbrace{[\,x_0,\; u_0,\; x_1,\; u_1,\;\ldots,\; x_N\,]}_{\mathbb{R}^{N(n_x+n_u)+n_x}}
\;\oplus\;
\underbrace{[\,s_0,\; s_1,\;\ldots,\; s_N\,]}_{\mathbb{R}^{(N+1)n_q}}
\]
</div>

<p>Index formulas from the code:</p>

<div class="cb"><div class="ct">src/mpc/qp_builder.py â€” index arithmetic (lines 50-51)</div>def idx_x(k): return k * (nx + nu)        # start of x_k in z
def idx_u(k): return k * (nx + nu) + nx   # start of u_k in z
slack_start  = n_z                         # start of slack block

# Sizes (nx=4, nu=2, nq=2)
n_z       = N*(nx+nu) + nx   = 6N + 4
n_slack   = (N+1)*nq          = 2N + 2
n_z_total = n_z + n_slack     = 8N + 6

# N=1: n_z_total=14   N=2: 22   N=20: 166</div>

<table class="tbl">
<tr><th>N</th><th>n_z</th><th>n_slack</th><th>n_z_total</th><th>z layout</th></tr>
<tr><td>1</td><td>10</td><td>4</td><td>14</td><td>xâ‚€[0:4], uâ‚€[4:6], xâ‚[6:10], sâ‚€[10:12], sâ‚[12:14]</td></tr>
<tr><td>2</td><td>16</td><td>6</td><td>22</td><td>xâ‚€[0:4],uâ‚€[4:6],xâ‚[6:10],uâ‚[10:12],xâ‚‚[12:16],sâ‚€[16:18],sâ‚[18:20],sâ‚‚[20:22]</td></tr>
<tr><td>20</td><td>124</td><td>42</td><td>166</td><td>â€¦</td></tr>
</table>

<h2>6.2 Cost Function â€” Factor-of-2 Convention</h2>

<div class="fix">
<div class="bt">KEY CORRECTION: Q stores 2Â·Qx, not Qx</div>
<p>OSQP minimises Â½z<sup>T</sup>Pz + q<sup>T</sup>z. To make the effective cost equal to
z<sup>T</sup>QxÂ·z (not z<sup>T</sup>QxÂ·z/2), the code stores <strong>2Â·Qx, 2Â·R, 2Â·Qf</strong> in the Q matrix
(lines 58-82). The linear term uses âˆ’2Â·QxÂ·xref correspondingly. The factor 2 cancels.</p>
</div>

<p>The effective (conceptual) cost is:</p>
<div class="eq">\[
J = \sum_{k=0}^{N-1}\bigl[(x_k - x_{\rm ref}^k)^\top Q_x(x_k-x_{\rm ref}^k)
    + u_k^\top R\,u_k\bigr]
+ (x_N - x_{\rm ref}^N)^\top Q_f(x_N - x_{\rm ref}^N)
+ Q_s\sum_{k=0}^{N}\|s_k\|^2
\]</div>

<p>In OSQP form (Q_osqp = 2Ã— everything, p_osqp = -2Ã—cross-terms):</p>
<div class="cb"><div class="ct">build_qp lines 57-82 â€” how Q and p are assembled</div># Stage k=0â€¦N-1: block at [idx_x(k):idx_x(k)+nx+nu, same]
H = 2.0 * block([[Qx, 0],[0, R]])      # 2Ã— because OSQP halves it
Q[start:start+nx+nu, start:start+nx+nu] += H

# Linear term for x_k: -2*Qx*xref (gradient of x^TÂ·QxÂ·x - 2*xref^TÂ·QxÂ·x)
p[idx_x(k):idx_x(k)+nx] += -2 * Qx @ xref[k]

# Terminal block at [idx_x(N):idx_x(N)+nx, same]
Q[start_xN:start_xN+nx, start_xN:start_xN+nx] += 2.0 * Qf
p[start_xN:start_xN+nx] += -2 * Qf @ xref[N]

# Slack penalty: 2*Qs*I at each slack block
Q[s_idx:s_idx+nq, s_idx:s_idx+nq] += 2.0 * Qs * I</div>

<p><strong>Default weights:</strong> Qx=diag(2000,2000,100,100), Qf=diag(5000,5000,200,200),
R=diag(0.001,0.001), Qs=10â¶. R is tiny because the arm needs ~10â€“30 NÂ·m just for gravity compensation.</p>

<h2>6.3 Equality Constraints â€” Initial Condition + Dynamics</h2>

<p>A_eq has <strong>(N+1)Â·nx rows</strong>: one nx-row block for the IC and N blocks for dynamics.</p>

<div class="cb"><div class="ct">build_qp lines 85-123 â€” equality constraints</div># â”€â”€ Initial condition (rows 0..nx-1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
row0[:, 0:nx] = I_nx        # z[0:4] = x0_actual
b_eq[0:nx] = x0             # right-hand side = given initial state
# This "pins" the xâ‚€ slot in z to the measured state.

# â”€â”€ Dynamics k=0â€¦N-1 (rows nx...(N+1)nx-1) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
for k in range(N):
    x_bar = x_ref_traj[k]      # operating point = reference, always qÌ‡=0
    A_c = A_fun(x_bar, u_bar)  # CasADi Jacobian
    B_c = B_fun(x_bar, u_bar)
    A_d = I + dt*A_c
    B_d = dt*B_c
    c_k = dt*(f_val - A_c @ x_bar - B_c @ u_bar)

    # Constraint: x_{k+1} - A_d*x_k - B_d*u_k = c_k
    row[:, idx_x(k):idx_x(k)+nx] = -A_d   # coefficient of x_k
    row[:, idx_u(k):idx_u(k)+nu] = -B_d   # coefficient of u_k
    row[:, idx_x(k+1):idx_x(k+1)+nx] = I  # coefficient of x_{k+1}
    b_eq[block] = c_k</div>

<h3>A_eq structure for N=1 (explicit, 8Ã—14)</h3>
<div class="cb"><div class="ct">A_eq for N=1, with column labels z=[xâ‚€(0-3), uâ‚€(4-5), xâ‚(6-9), sâ‚€(10-11), sâ‚(12-13)]</div>       xâ‚€cols 0-3    uâ‚€cols 4-5   xâ‚cols 6-9   slack cols
Row 0-3  [  Iâ‚„        |   0â‚„â‚“â‚‚   |   0â‚„â‚“â‚„   |   0â‚„â‚“â‚„  ]  b=[xâ‚€]   â† IC
Row 4-7  [ -Aáµˆ        |  -Báµˆ     |   Iâ‚„      |   0     ]  b=[c_k] â† dynamics k=0</div>

<h2>6.4 Inequality Constraints â€” Three Groups</h2>

<table class="tbl">
<tr><th>Group</th><th>Type</th><th>Variables</th><th>Constraint</th><th>Rows per k</th></tr>
<tr><td>Torque upper</td><td>Hard</td><td>u_k</td><td>u_k â‰¤ Ï„_max</td><td>nu=2</td></tr>
<tr><td>Torque lower</td><td>Hard</td><td>u_k</td><td>âˆ’u_k â‰¤ âˆ’Ï„_min</td><td>nu=2</td></tr>
<tr><td>Angle upper+slack</td><td>Soft</td><td>Î¸_k, s_k</td><td>Î¸_k âˆ’ s_k â‰¤ Î¸_max</td><td>nq=2</td></tr>
<tr><td>Angle lower+slack</td><td>Soft</td><td>Î¸_k, s_k</td><td>âˆ’Î¸_k âˆ’ s_k â‰¤ âˆ’Î¸_min</td><td>nq=2</td></tr>
<tr><td>Slack non-neg</td><td>Hard</td><td>s_k</td><td>âˆ’s_k â‰¤ 0</td><td>nq=2</td></tr>
</table>

<p>Loop runs for k=0â€¦N-1 (stage) plus a terminal block at k=N (angle+slack rows only, no torque).
Rows per stage: 2+2+2+2+2=10. Terminal: 2+2+2=6. Total A_ineq rows: <strong>10N+6</strong>.</p>

<div class="cb"><div class="ct">A_ineq structure for N=1 (16Ã—14), showing non-zero column patterns</div>z-cols:  xâ‚€(0-3)  uâ‚€(4-5)  xâ‚(6-9)  sâ‚€(10-11)  sâ‚(12-13)

â”€â”€ k=0 stage â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Row 0-1  [  0      |  +Iâ‚‚    |   0    |    0     |    0   ]  â‰¤ Ï„_max  (uâ‚€ â‰¤ 50)
Row 2-3  [  0      |  -Iâ‚‚    |   0    |    0     |    0   ]  â‰¤ -Ï„_min (uâ‚€ â‰¥ -50)
Row 4-5  [ +Iâ‚‚|0â‚‚  |   0     |   0    |   -Iâ‚‚    |    0   ]  â‰¤ Î¸_max  (Î¸â‚€ âˆ’ sâ‚€ â‰¤ Ï€)
Row 6-7  [ -Iâ‚‚|0â‚‚  |   0     |   0    |   -Iâ‚‚    |    0   ]  â‰¤ -Î¸_min (âˆ’Î¸â‚€ âˆ’ sâ‚€ â‰¤ Ï€)
Row 8-9  [  0      |   0     |   0    |   -Iâ‚‚    |    0   ]  â‰¤ 0      (sâ‚€ â‰¥ 0)

NOTE: rows 4-9 use Î¸_0 (from xâ‚€!), i.e. the first nq elements of x_k at k=0.

â”€â”€ terminal k=N=1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Row 10-11 [  0     |   0    |  +Iâ‚‚|0â‚‚ |    0     |   -Iâ‚‚  ]  â‰¤ Î¸_max  (Î¸â‚ âˆ’ sâ‚ â‰¤ Ï€)
Row 12-13 [  0     |   0    |  -Iâ‚‚|0â‚‚ |    0     |   -Iâ‚‚  ]  â‰¤ -Î¸_min
Row 14-15 [  0     |   0    |   0 |0â‚‚ |    0     |   -Iâ‚‚  ]  â‰¤ 0      (sâ‚ â‰¥ 0)

k_ineq = [50,50, 50,50, Ï€,Ï€, Ï€,Ï€, 0,0, Ï€,Ï€, Ï€,Ï€, 0,0]</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why soft constraints for angles but hard for torques?</div>
<p><strong>Hard constraints</strong> (torque): the actuator physically cannot exceed Ï„_max.
OSQP must always satisfy these â€” they never become inactive.</p>
<p><strong>Soft constraints</strong> (angle): if the arm is already slightly past Î¸_max (e.g. after an
external push), hard constraints would make the QP infeasible. Soft constraints keep the QP solvable
at all times â€” violations are allowed but cost 2Â·Qs = 2Ã—10â¶ per unitÂ² of violation, making them
effectively forbidden in practice.</p>
<p>With Qs=10â¶ and R=0.001: 1 rad of angle violation costs 2Ã—10â¶ cost units,
while 1 NÂ·m of extra torque costs only 0.001 units â†’ angle constraint is 2Ã—10â¹ times more expensive to violate.</p>
</div>

<h2>6.5 Complete Dimension Table</h2>

<table class="tbl">
<tr><th>Object</th><th>Shape (general N)</th><th>N=1</th><th>N=2</th><th>N=20</th></tr>
<tr><td>z</td><td>(8N+6,)</td><td>14</td><td>22</td><td>166</td></tr>
<tr><td>Q (cost Hessian)</td><td>(8N+6)Â²</td><td>14Ã—14</td><td>22Ã—22</td><td>166Ã—166</td></tr>
<tr><td>p (linear cost)</td><td>(8N+6,)</td><td>14</td><td>22</td><td>166</td></tr>
<tr><td>A_eq</td><td>4(N+1) Ã— (8N+6)</td><td>8Ã—14</td><td>12Ã—22</td><td>84Ã—166</td></tr>
<tr><td>b_eq</td><td>(4(N+1),)</td><td>8</td><td>12</td><td>84</td></tr>
<tr><td>A_ineq</td><td>(10N+6) Ã— (8N+6)</td><td>16Ã—14</td><td>26Ã—22</td><td>206Ã—166</td></tr>
<tr><td>k_ineq</td><td>(10N+6,)</td><td>16</td><td>26</td><td>206</td></tr>
</table>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 7 -->
<h1 id="s7">7 Â· OSQP Wrapping â€” Exact Mapping</h1>

<p>OSQP solves: \(\min \frac{1}{2}z^\top P z + q^\top z \text{ s.t. } l \le Az \le u\).
The mapping from the 6-tuple is straightforward (see <code>osqp_solver.py</code> lines 20â€“23):</p>

<div class="cb"><div class="ct">src/solver/osqp_solver.py â€” complete solve() method</div>def solve(self, qp_matrices):
    Q, p, A_eq, b_eq, A_ineq, k_ineq = qp_matrices

    # Merge equality and inequality into single A, l, u
    A = vstack([A_eq, A_ineq])
    l = concat([b_eq, -inf * ones(len(k_ineq))])   # equality: l=u=b_eq
    u = concat([b_eq, k_ineq])                      # inequality: l=-inf, u=k_ineq

    P_sp = sparse.csc_matrix(Q)   # Q already has factor 2 â†’ correct for OSQP's Â½z'Pz
    A_sp = sparse.csc_matrix(A)

    prob = osqp.OSQP()
    prob.setup(P=P_sp, q=p, A=A_sp, l=l, u=u,
               verbose=False, eps_abs=1e-4, eps_rel=1e-4, warm_start=True)
    res = prob.solve()
    return res.x   # full z*</div>

<table class="tbl">
<tr><th>OSQP arg</th><th>Comes from</th><th>Notes</th></tr>
<tr><td>P</td><td>Q (from build_qp)</td><td>Already 2Ã—-scaled; OSQP halves it â†’ effective Qx</td></tr>
<tr><td>q</td><td>p (from build_qp)</td><td>Contains âˆ’2Â·QxÂ·xref; pairs with the factor-2 Q</td></tr>
<tr><td>A (rows 0..4N+3)</td><td>A_eq</td><td>Equality: l=u=b_eq enforces x_{k+1}=A_d x_k+B_d u_k+c_k</td></tr>
<tr><td>A (rows 4N+4..end)</td><td>A_ineq</td><td>Inequalities: l=âˆ’âˆ, u=k_ineq</td></tr>
<tr><td>l (eq part)</td><td>b_eq</td><td>l=u pins equalities exactly</td></tr>
<tr><td>u (eq part)</td><td>b_eq</td><td>Same as l â†’ equality constraint</td></tr>
<tr><td>u (ineq part)</td><td>k_ineq</td><td>Upper bounds: Ï„_max, Î¸_max, etc.</td></tr>
</table>

<div class="ref">
<div class="rt">ğŸ“– Stellato et al. â€” "OSQP: an operator splitting solver for quadratic programs,"
<em>Mathematical Programming Computation</em> 12, 637â€“672, 2020</div>
<div class="rq">"We consider convex QPs of the form min Â½xáµ€Px + qáµ€x s.t. l â‰¤ Ax â‰¤ u,
where xâˆˆâ„â¿, Pâˆˆğ•Šâ¿â‚Š, Aâˆˆâ„áµË£â¿, qâˆˆâ„â¿, lâˆˆ(â„âˆª{âˆ’âˆ})áµ, uâˆˆ(â„âˆª{+âˆ})áµ." (Â§1, Eq. 1)</div>
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi:10.1007/s12532-020-00179-2</a> |
<a href="https://osqp.org">osqp.org</a>
</div>

<p><strong>Why re-initialize every step?</strong> The comment in the code says: "the linearized A
matrix structure/values change significantly." Since Aáµˆ and Báµˆ change at each timestep (different
operating point), OSQP's internal sparsity pattern would need updating. Re-init is safe and fast
for the small QP sizes here.</p>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 8 -->
<h1 id="s8">8 Â· Hand-Solved N=1 QP â€” Case A (g=0)</h1>

<p>We use <strong>Case A</strong> (g=0, q=[0,0], N=1, dt=0.1s) with simplified weights to keep
arithmetic manageable. Use <code>run_all_cases(['A'])</code> to verify every matrix entry.</p>

<table class="tbl">
<tr><th>Parameter</th><th>Hand value</th><th>Code default (N=20)</th></tr>
<tr><td>g</td><td>0 (gravity off)</td><td>9.81</td></tr>
<tr><td>N</td><td>1</td><td>20</td></tr>
<tr><td>dt</td><td>0.1 s</td><td>0.02 s</td></tr>
<tr><td>Qx=Qf</td><td>diag(1,1,0,0) (positions only)</td><td>diag(2000,2000,100,100)</td></tr>
<tr><td>R</td><td>diag(0.1,0.1)</td><td>diag(0.001,0.001)</td></tr>
<tr><td>Qs</td><td>0 (ignore slacks)</td><td>1e6</td></tr>
</table>

<h2>8.1 z layout and matrix sizes (N=1)</h2>

<div class="cb"><div class="ct">Decision vector z âˆˆ â„Â¹â´ for N=1</div>z = [ xâ‚€ | uâ‚€ | xâ‚ | sâ‚€ | sâ‚ ]
     0-3   4-5  6-9  10-11 12-13

xâ‚€ = [qâ‚â°, qâ‚‚â°, qÌ‡â‚â°, qÌ‡â‚‚â°]   initial state (pinned by IC constraint)
uâ‚€ = [Ï„â‚â°, Ï„â‚‚â°]               control at step 0
xâ‚ = [qâ‚Â¹, qâ‚‚Â¹, qÌ‡â‚Â¹, qÌ‡â‚‚Â¹]   predicted state at step 1
sâ‚€ = [sâ‚â°, sâ‚‚â°]               angle slack at step 0
sâ‚ = [sâ‚Â¹, sâ‚‚Â¹]               angle slack at step 1 (terminal)</div>

<h2>8.2 Cost matrices Q (14Ã—14) and p (14)</h2>

<div class="cb"><div class="ct">Q diagonal entries (Qs=0 for simplicity)</div>Q = diag(
  2Â·Qx, 2Â·R,    â† stage: xâ‚€ and uâ‚€
  2Â·Qf,         â† terminal: xâ‚
  0, 0, 0, 0    â† slacks (Qs=0 here)
)
= diag(2,2,0,0, 0.2,0.2, 2,2,0,0, 0,0,0,0)
         â†‘xâ‚€          â†‘uâ‚€     â†‘xâ‚

p = [ -2Â·QxÂ·xref[0],  0, 0,    â† xâ‚€ and uâ‚€ parts
      -2Â·QfÂ·xref[1],           â† xâ‚ part
      0, 0, 0, 0 ]              â† slacks

With xâ‚€=[0,0,0,0] (start), x_goal=[Ï€/3, Ï€/6, 0, 0]:
  xref[0] = [0, 0, 0, 0]       â†’ p[0:4] = [0, 0, 0, 0]
  xref[1] = [Ï€/3, Ï€/6, 0, 0]   â†’ p[6:8] = [-2Â·(Ï€/3), -2Â·(Ï€/6)] â‰ˆ [-2.094, -1.047]
  p = [0,0,0,0, 0,0, -2.094,-1.047,0,0, 0,0,0,0]</div>

<h2>8.3 Equality constraints A_eq (8Ã—14) and b_eq</h2>

<div class="cb"><div class="ct">A_eq and b_eq â€” rows annotated</div>Row 0: z[0]=1          â†’ b[0]=0   (qâ‚â° = xâ‚€[0] = 0)
Row 1: z[1]=1          â†’ b[1]=0
Row 2: z[2]=1          â†’ b[2]=0
Row 3: z[3]=1          â†’ b[3]=0

(IC block: A_eq[0:4, 0:4] = Iâ‚„, b_eq[0:4] = xâ‚€ = [0,0,0,0])

Row 4-7 (dynamics k=0):  zâ‚ = AáµˆÂ·zâ‚€ + BáµˆÂ·uâ‚€ + c_k
  A_eq[4:8, 0:4] = -Aáµˆ = -Iâ‚„  (since Aáµˆ=I for double integrator at dtâ†’0 cols 0-1, dt for cols 2-3)
  A_eq[4:8, 4:6] = -Báµˆ
  A_eq[4:8, 6:10] = +Iâ‚„
  b_eq[4:8] = c_k = [0,0,0,0]

Recall Aáµˆ (Case A, dt=0.1):
  Aáµˆ = [[1,0,0.1,0],[0,1,0,0.1],[0,0,1,0],[0,0,0,1]]

Báµˆ = 0.1Â·Bâ‚“ = [[0,0],[0,0],[0.686,-1.714],[-1.714,5.486]]

-Aáµˆ =  [[-1,0,-0.1,0],[0,-1,0,-0.1],[0,0,-1,0],[0,0,0,-1]]
-Báµˆ =  [[0,0],[0,0],[-0.686,1.714],[1.714,-5.486]]

Full A_eq (8Ã—14), showing col indices:
cols: [  0     1     2     3     4      5      6    7    8    9   10 11 12 13]
row4: [ -1     0   -0.1    0     0      0      1    0    0    0    0  0  0  0] b=0
row5: [  0    -1    0    -0.1    0      0      0    1    0    0    0  0  0  0] b=0
row6: [  0     0   -1     0   -0.686  1.714    0    0    1    0    0  0  0  0] b=0
row7: [  0     0    0    -1    1.714 -5.486    0    0    0    1    0  0  0  0] b=0</div>

<h2>8.4 Analytical Solution (Bounds Inactive)</h2>

<p>With Qs=0 and bounds inactive, slacks drop out. The IC constraint pins z[0:4]=xâ‚€=[0,0,0,0].
Dynamics gives z[6:10] = xâ‚ = BáµˆÂ·uâ‚€ (since AáµˆÂ·xâ‚€=0 and c_k=0).</p>

<p>The cost becomes (substituting xâ‚€=0, xâ‚=BáµˆÂ·uâ‚€, slacks=0):</p>
<div class="eq">\[
J(u_0) = u_0^\top R\,u_0 + (B_d u_0)^\top Q_f(B_d u_0) + p_{x_1}^\top B_d u_0
= u_0^\top \underbrace{(R + B_d^\top Q_f B_d)}_{H}\,u_0 + \underbrace{p_{x_1}^\top B_d}_{q^\top}\,u_0
\]</div>

<div class="eq">\[
\frac{\partial J}{\partial u_0} = 2H u_0 + q = 0
\quad\Rightarrow\quad
u_0^* = -\tfrac{1}{2}H^{-1}q = H^{-1} B_d^\top Q_f x_{\rm ref}^1
\]</div>

<div class="cb"><div class="ct">Numerical solution (run with qp_inspector to verify)</div>Báµˆáµ€QfBáµˆ = 0.1Â² Â· Mâ»Â¹áµ€Â·diag(1,1,0,0)Â·Mâ»Â¹
  = 0.01 Â· [[Bc[2,0]Â²+Bc[3,0]Â², Bc[2,0]Bc[2,1]+Bc[3,0]Bc[3,1]],
             [same,              Bc[2,1]Â²+Bc[3,1]Â²]]  â† ONLY velocity rows of Qf

With Qx=Qf=diag(1,1,0,0) only the position rows contribute, and since
Báµˆ has zeros in position rows, Báµˆ'Â·QfÂ·Báµˆ = 0!

H = R + 0 = diag(0.1, 0.1)

Báµˆáµ€Â·QfÂ·xref[1] with xref[1]=[Ï€/3,Ï€/6,0,0]:
  = Báµˆáµ€ Â· [Ï€/3, Ï€/6, 0, 0] = [0Â·Ï€/3 + 0Â·Ï€/6, 0Â·Ï€/3 + 0Â·Ï€/6] = [0, 0]

uâ‚€* = Hâ»Â¹Â·[0,0] = [0, 0]

This makes physical sense! With g=0, Qf on positions only, and N=1:
any torque creates velocity, not position change. The QP correctly
concludes uâ‚€*=0 (can't reach position goal in one step via impulse).</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Why does N=1 with position cost give uâ‚€*=0?</div>
With Euler discretisation: xâ‚ = [qâ‚+dtÂ·qÌ‡â‚, qâ‚‚+dtÂ·qÌ‡â‚‚, qÌ‡â‚+dtÂ·Mâ»Â¹Ï„, qÌ‡â‚‚+dtÂ·Mâ»Â¹Ï„].
Position at step 1 is qâ‚+dtÂ·qÌ‡â‚ â€” independent of torque Ï„! Torque affects velocity,
not position, in one step. So Báµˆáµ€Â·âˆ‚J/âˆ‚xâ‚ through the position part = 0.
To drive a position cost with torque, you need Nâ‰¥2 (so the velocity created at step 1
propagates to position at step 2).
</div>

<p><strong>Use code weights for a non-trivial result:</strong></p>
<div class="dark"><div class="cfh">verify via qp_inspector</div>from src.utils.qp_inspector import build_case, verify_solution
from src.solver.osqp_solver import OSQPSolver
import numpy as np

r = build_case('A')   # g=0, N=1, code default weights (Qf has 100/200 on velocity!)
z_star = OSQPSolver().solve(r['qp_matrices'])
nx, nu = r['arm'].nx, r['arm'].nu
print("u0* =", z_star[nx:nx+nu])          # non-zero because Qf has velocity terms
verify_solution(z_star, r['qp_matrices'])</div>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 9 -->
<h1 id="s9">9 Â· Hand-Solved N=2 QP â€” Case B (g=9.81)</h1>

<p>N=2 shows multi-step lookahead and the gravity gradient effect. Use Case B (g=9.81, q=[0,0])
with simplified weights: Qx=Qf=diag(1,1,0,0), R=diag(0.1,0.1), Qs=0.</p>

<h2>9.1 z layout for N=2</h2>

<div class="cb"><div class="ct">z âˆˆ â„Â²Â² for N=2</div>z = [xâ‚€(0-3) | uâ‚€(4-5) | xâ‚(6-9) | uâ‚(10-11) | xâ‚‚(12-15) | sâ‚€(16-17) | sâ‚(18-19) | sâ‚‚(20-21)]</div>

<h2>9.2 Q diagonal (22Ã—22)</h2>

<div class="cb"><div class="ct">Q diagonal entries for N=2, Qs=0</div>Q = diag(
  2Â·1, 2Â·1, 0, 0,          â† xâ‚€: 2Â·Qx (positions only)
  0.2, 0.2,                 â† uâ‚€: 2Â·R
  2Â·1, 2Â·1, 0, 0,          â† xâ‚: 2Â·Qx
  0.2, 0.2,                 â† uâ‚: 2Â·R
  2Â·1, 2Â·1, 0, 0,          â† xâ‚‚: 2Â·Qf (same as Qx here)
  0,0, 0,0, 0,0             â† slacks (Qs=0)
)</div>

<h2>9.3 Equality constraints A_eq (12Ã—22)</h2>

<div class="cb"><div class="ct">A_eq structure â€” IC row + 2 dynamics rows</div>Row 0-3:   IC: A_eq[0:4, 0:4]=I, b=[xâ‚€]

Row 4-7:  k=0 dynamics (Aáµˆ_B, Báµˆ, c_k=0):
  A_eq[4:8, 0:4]  = -Aáµˆ_B   (xâ‚€ coefficient)
  A_eq[4:8, 4:6]  = -Báµˆ     (uâ‚€ coefficient)
  A_eq[4:8, 6:10] = I        (xâ‚ coefficient)
  b_eq[4:8] = [0,0,0,0]

Recall Aáµˆ_B (Case B, dt=0.1):
  [[1,0,0.1,0],[0,1,0,0.1],[-2.523,2.523,1,0],[3.363,-9.249,0,1]]

Row 8-11: k=1 dynamics (same Aáµˆ_B and Báµˆ since ref is still at [0,0,0,0]):
  A_eq[8:12, 6:10]  = -Aáµˆ_B   (xâ‚ coefficient)
  A_eq[8:12, 10:12] = -Báµˆ     (uâ‚ coefficient)
  A_eq[8:12, 12:16] = I        (xâ‚‚ coefficient)
  b_eq[8:12] = [0,0,0,0]</div>

<h2>9.4 Analytical Two-Step Solution</h2>

<p>With IC xâ‚€=[0,0,0,0] and bounds inactive:</p>
<div class="eq">\[
x_1 = A_d\,x_0 + B_d\,u_0 + c_k = B_d\,u_0
\]</div>
<div class="eq">\[
x_2 = A_d\,x_1 + B_d\,u_1 + c_k = A_d B_d\,u_0 + B_d\,u_1
\]</div>

<p>Cost (positions only, Qf=Qx=diag(1,1,0,0)):</p>
<div class="eq">\[
J = q_1^{(1)2} + q_2^{(1)2} + 0.1(Ï„_{1}^{(0)2}+Ï„_{2}^{(0)2}) + q_1^{(2)2} + q_2^{(2)2}
    + 0.1(Ï„_{1}^{(1)2}+Ï„_{2}^{(1)2}) + \text{linear terms}
\]</div>

<p>Since Báµˆ has zeros in position rows (rows 0-1), the position entries of xâ‚ and xâ‚‚ are:</p>
<div class="eq">\[q^{(1)} = q^{(0)} + dt \cdot \dot{q}^{(0)} = 0 + 0.1\cdot(B_c u_0)_{q} = 0
\quad (\text{since }B_c\text{ upper block} = 0)\]</div>
<div class="eq">\[q^{(2)} = A_d^{qq}\,q^{(1)} + A_d^{qv}\,\dot{q}^{(1)} = dt\cdot\dot{q}^{(1)}\]</div>

<p>So qâ‚Â² at step 2 depends on uâ‚€ through the velocity created at step 1! This is why N=2 gives
uâ‚€*â‰ 0 with a position cost, while N=1 gave uâ‚€*=0.</p>

<div class="dark"><div class="cfh">reproduce with qp_inspector</div>from src.utils.qp_inspector import build_case, print_matrices, verify_solution
from src.solver.osqp_solver import OSQPSolver
import numpy as np

# Case B, N=2, simplified weights
r = build_case('B_N2',
    Qx=np.diag([1.,1.,0.,0.]),
    Qf=np.diag([1.,1.,0.,0.]),
    R=np.diag([0.1,0.1]))

print_matrices(r['qp_matrices'], r['N'], case_name='B_N2_simplified')

z = OSQPSolver().solve(r['qp_matrices'])
nx, nu = r['arm'].nx, r['arm'].nu
print("u0* =", z[nx:nx+nu])
print("u1* =", z[3*(nx//2+nu//2):3*(nx//2+nu//2)+nu])  # rough
verify_solution(z, r['qp_matrices'])</div>

<div class="result">
<div class="bt">What changes from N=1 to N=2</div>
<p>In N=1: uâ‚€*=0 (position cost can't be reduced in one Euler step via torque).</p>
<p>In N=2: uâ‚€*â‰ 0 because the controller knows torque at step 0 creates velocity at step 1
which creates position change at step 2 â†’ Báµˆ couples through Aáµˆ over two steps.</p>
<p>Larger N â†’ more lookahead â†’ more "aggressive" uâ‚€ (applies force now knowing it will be
corrected later). This is the fundamental power of MPC's receding-horizon structure.</p>
</div>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 10 -->
<h1 id="s10">10 Â· N=1 with Active Torque Constraint â€” Case C_tight</h1>

<p>Case C_tight is Case C (g=9.81, q=[Ï€/6,0]) but with Ï„_max=5 NÂ·m â€” tight enough that
the gravity compensation torque alone would violate it if the controller is aggressive.
This demonstrates active inequality constraints and their effect on the OSQP dual variables.</p>

<div class="cb"><div class="ct">Expected behaviour</div>At q=[Ï€/6, 0], gravity compensation requires u_bar=[4.905, 1.226] NÂ·m.
With Ï„_max=5 NÂ·m, Ï„â‚ can only go 0.095 NÂ·m above the gravity compensation level.
â†’ The QP will hit the Ï„â‚ upper bound â†’ one KKT multiplier becomes > 0.

Code: use build_case('C_tight') or add --torque_max 5 in main.py --case C</div>

<div class="dark"><div class="cfh">reproduce and examine active constraint</div>from src.utils.qp_inspector import build_case, verify_solution, run_all_cases
from src.solver.osqp_solver import OSQPSolver
import numpy as np

r = build_case('C_tight')    # tight torque bound
z = OSQPSolver().solve(r['qp_matrices'])

nx, nu = r['arm'].nx, r['arm'].nu
print("u0* =", z[nx:nx+nu])           # expect Ï„â‚* â‰ˆ 5.0 (at bound)
print("x1* =", z[nx+nu:2*nx+nu])      # predicted next state

# Check constraint: should be Active (Ï„â‚ = Ï„_max)
print("Ï„_max margin Ï„â‚:", 5.0 - z[nx])
verify_solution(z, r['qp_matrices'], verbose=True)</div>

<div class="intuit">
<div class="bt">ğŸ’¡ Reading the dual variables (KKT multipliers)</div>
<p>When a constraint is <em>active</em> (uâ‚€=Ï„_max), its KKT multiplier Î» > 0.
This means the constraint is "pushing back" on the optimum.</p>
<p>OSQP returns <code>res.y</code> â€” the dual variable for each row of the combined A matrix.
Rows 0â€¦4(N+1)-1 â†’ equality multipliers. Rows 4(N+1)â€¦ â†’ inequality multipliers.</p>
<p>A positive multiplier on the Ï„â‚ upper-bound row means: "if I relaxed Ï„_max by 1 NÂ·m,
the cost would decrease by Î»." This is the economic value of relaxing the constraint.</p>
<p><strong>Inactive constraints</strong> have Î»=0 â€” the constraint doesn't affect the optimum.</p>
</div>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 11 -->
<h1 id="s11">11 Â· Code-Level Walkthrough â€” Every File</h1>

<h2>11.1 <code>src/dynamics/arm2dof.py</code> â€” Arm2DOF</h2>

<table class="tbl">
<tr><th>Method / Attribute</th><th>What it does</th><th>Key lines</th></tr>
<tr><td><code>__init__</code></td><td>Store m1,m2,l1,l2,g; call _build_casadi()</td><td>L10-25</td></tr>
<tr><td><code>_build_casadi()</code></td><td>CasADi symbolic M,C,G; compute ddq=Mâ»Â¹(Ï„-CÂ·qÌ‡-G); define f_fun, A_fun, B_fun</td><td>L28-72</td></tr>
<tr><td><code>f_fun(x,u)</code></td><td>Returns [qÌ‡â‚, qÌ‡â‚‚, qÌˆâ‚, qÌˆâ‚‚] symbolically</td><td>L66</td></tr>
<tr><td><code>A_fun(x,u)</code></td><td>Returns 4Ã—4 Jacobian âˆ‚f/âˆ‚x via ca.jacobian</td><td>L67</td></tr>
<tr><td><code>B_fun(x,u)</code></td><td>Returns 4Ã—2 Jacobian âˆ‚f/âˆ‚u via ca.jacobian</td><td>L68</td></tr>
<tr><td><code>step_dynamics(x,u,dt)</code></td><td>Euler step: x_next = x + dtÂ·f(x,u)</td><td>L80-83</td></tr>
<tr><td><code>get_M(q)</code></td><td>Returns M(q) as numpy 2Ã—2</td><td>L86-88</td></tr>
<tr><td><code>forward_kinematics(q)</code></td><td>Returns (x1,y1,x2,y2) of link endpoints</td><td>L90-99</td></tr>
<tr><td>nx=4, nu=2, nq=2</td><td>Dimension constants used by MPCBuilder</td><td>L24-26</td></tr>
</table>

<h2>11.2 <code>src/mpc/qp_builder.py</code> â€” MPCBuilder</h2>

<table class="tbl">
<tr><th>Method</th><th>What it does</th><th>Key output</th></tr>
<tr><td><code>__init__(arm, N, dt, ...)</code></td><td>Store arm, horizon, dt, weights; define index helpers idx_x, idx_u</td><td>Stores Qx,R,Qf,Qs, Ï„_max, Î¸_max, Î¸_min</td></tr>
<tr><td><code>build_reference_trajectory(x0, x_goal)</code></td><td>Linear interp in angles from x0 to x_goal over N+1 steps; velocities always 0</td><td>x_ref_traj (N+1)Ã—4</td></tr>
<tr><td><code>build_qp(x0, x_ref_traj)</code></td><td>Full QP assembly: cost â†’ equalities â†’ inequalities</td><td>Q, p, A_eq, b_eq, A_ineq, k_ineq</td></tr>
<tr><td>inner loop k=0â€¦N-1</td><td>For each step: evaluate A_fun, B_fun at x_ref_traj[k]; Euler discretise; add cost and constraint rows</td><td>Rows added to all 6 matrices</td></tr>
</table>

<div class="cb"><div class="ct">Key design detail: reference trajectory velocities = 0</div>def build_reference_trajectory(self, x0, x_goal):
    ...
    for k in range(N+1):
        alpha = k / N
        x_ref[k, :nq] = (1-alpha)*x0[:nq] + alpha*x_goal[:nq]  # interpolate positions
        x_ref[k, nq:] = 0.0                                       # ALWAYS zero velocity
    return x_ref
# Consequence: Ac lower-right (Coriolis velocity) block = 0 in all MPCBuilder QPs</div>

<h2>11.3 <code>src/solver/osqp_solver.py</code> â€” OSQPSolver</h2>

<div class="cb"><div class="ct">Complete solve flow</div>def solve(self, qp_matrices):
    Q, p, A_eq, b_eq, A_ineq, k_ineq = qp_matrices
    A = vstack([A_eq, A_ineq])
    l = concat([b_eq, -infÂ·ones(len(k_ineq))])
    u = concat([b_eq, k_ineq])
    P_sp = csc_matrix(Q)
    A_sp = csc_matrix(A)
    prob = osqp.OSQP()
    prob.setup(P_sp, q=p, A=A_sp, l=l, u=u,
               verbose=False, eps_abs=1e-4, eps_rel=1e-4, warm_start=True)
    return prob.solve().x    # returns z* (full, including slacks)</div>

<h2>11.4 <code>src/utils/logger.py</code> â€” QPLogger</h2>

<p>Saves every MPC step as an <code>.npz</code> file containing: Q, p, A_eq, b_eq, A_ineq,
k_ineq, z_star, x, u_applied, t. Use <code>np.load(file, allow_pickle=True)</code> to
inspect any step offline. The <code>--export_qp</code> flag in <code>main.py</code> also
triggers an extra export of step 0 for study purposes.</p>

<h2>11.5 <code>src/utils/visualization.py</code> â€” ArmAnimator</h2>

<div class="cb"><div class="ct">Animation architecture</div>class ArmAnimator:
    def __init__(self, arm, controller, data_log):
        # Uses matplotlib FuncAnimation
        # forward_kinematics gives link endpoint positions for plotting
        
    def update(self, frame):
        q = self.data_log[frame]['q']
        x1, y1, x2, y2 = self.arm.forward_kinematics(q)
        self.link1.set_data([0, x1], [0, y1])
        self.link2.set_data([x1, x2], [y1, y2])
        return self.link1, self.link2</div>

<h2>11.6 <code>src/utils/qp_inspector.py</code> â€” QPInspector (new in v3)</h2>

<p>A standalone helper that imports Arm2DOF, MPCBuilder, OSQPSolver and provides:</p>

<table class="tbl">
<tr><th>Function</th><th>Purpose</th></tr>
<tr><td><code>build_case(name, **kw)</code></td><td>Instantiate arm+mpc with canonical settings; return arm, mpc, qp_matrices, N</td></tr>
<tr><td><code>inspect_linearisation(case_name)</code></td><td>Print Ac, Bc, M, G, f at case's operating point</td></tr>
<tr><td><code>inspect_at_point(arm, x_bar, u_bar, dt)</code></td><td>Evaluate linearisation at arbitrary (non-zero-velocity) point â€” for Case E</td></tr>
<tr><td><code>print_matrices(qp_matrices, N)</code></td><td>Pretty-print all 6 QP matrices with index labels</td></tr>
<tr><td><code>verify_solution(z, qp_matrices)</code></td><td>Check equality residual, inequality violations, KKT conditions</td></tr>
<tr><td><code>export_case_npz(case_name)</code></td><td>Save QP + optional solution to .npz for MATLAB/Julia comparison</td></tr>
<tr><td><code>run_all_cases()</code></td><td>Loop all canonical cases; verify all pass; print summary table</td></tr>
</table>

<h2>11.7 <code>interactive_arm.py</code> â€” Interactive Demo</h2>

<div class="cb"><div class="ct">Run interactive arm with all toggles</div>python3 interactive_arm.py              # default (g=9.81)
python3 interactive_arm.py --gravity 0  # gravity off

Controls: click canvas â†’ set goal
          "Gravity ON/OFF" button â†’ toggle g
          "MPC ON/OFF" button â†’ toggle controller</div>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 12 -->
<h1 id="s12">12 Â· QP Inspector Usage Guide</h1>

<p>All canonical cases are defined in <code>CANONICAL_CASES</code> at the top of
<code>src/utils/qp_inspector.py</code>. Run from the repo root:</p>

<div class="dark"><div class="cfh">terminal</div># Run all cases and verify solutions
python3 -c "from src.utils.qp_inspector import run_all_cases; run_all_cases()"

# Inspect linearisation for Case C
python3 -c "from src.utils.qp_inspector import inspect_linearisation; inspect_linearisation('C')"

# Print all QP matrices for Case B_N2
python3 -c "
from src.utils.qp_inspector import build_case, print_matrices
r = build_case('B_N2')
print_matrices(r['qp_matrices'], r['N'], case_name='B_N2')
"

# Export Case A for external verification
python3 -c "from src.utils.qp_inspector import export_case_npz; export_case_npz('A')"

# Show full Case E with Coriolis (non-zero velocity operating point)
python3 -c "from src.utils.qp_inspector import print_case_e_full; print_case_e_full()"</div>

<h2>12.1 CANONICAL_CASES Dictionary Reference</h2>

<table class="tbl">
<tr><th>Name</th><th>g</th><th>q_bar</th><th>N</th><th>Special</th></tr>
<tr><td>A</td><td>0</td><td>[0,0]</td><td>1</td><td>Double integrator, all matrices trivial</td></tr>
<tr><td>B</td><td>9.81</td><td>[0,0]</td><td>1</td><td>Gravity stiffness in Ac, c_k=0</td></tr>
<tr><td>B_N2</td><td>9.81</td><td>[0,0]</td><td>2</td><td>Two-step horizon, lookahead demo</td></tr>
<tr><td>C</td><td>9.81</td><td>[Ï€/6,0]</td><td>1</td><td>Gâ‰ 0, u_barâ‰ 0, c_kâ‰ 0</td></tr>
<tr><td>C_tight</td><td>9.81</td><td>[Ï€/6,0]</td><td>1</td><td>Ï„_max=5: active constraint demo</td></tr>
<tr><td>D</td><td>9.81</td><td>[0,Ï€/2]</td><td>1</td><td>Clean Mâ»Â¹=[[3,-3],[-3,15]], c_k[3]â‰ 0</td></tr>
<tr><td>E_static</td><td>9.81</td><td>[0,Ï€/4]</td><td>1</td><td>Intermediate angle, inspect_at_point for Coriolis</td></tr>
</table>

<h2>12.2 Adding Custom Cases</h2>

<div class="dark"><div class="cfh">python</div>from src.utils.qp_inspector import build_case, verify_solution, print_matrices
from src.solver.osqp_solver import OSQPSolver
import numpy as np

# Custom: g=9.81, q=[Ï€/4, Ï€/4], N=3, tight bounds
r = build_case('D',   # base case D
    N=3,
    q_init=np.array([np.pi/4, np.pi/4, 0.0, 0.0]),
    q_goal=np.array([np.pi/2, np.pi/2, 0.0, 0.0]),
    torque_max=30.0)

print_matrices(r['qp_matrices'], r['N'])
z = OSQPSolver().solve(r['qp_matrices'])
verify_solution(z, r['qp_matrices'], tol=1e-4, verbose=True)</div>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 13 -->
<h1 id="s13">13 Â· Validation Lab Manual â€” Step-by-Step Checklist</h1>

<p>Follow these steps in order to fully verify the system from first principles to live simulation.</p>

<h2>Step 1 â€” Verify Physical Model (5 min)</h2>
<div class="cb"><div class="ct">Test arm dynamics at known configurations</div>python3 -c "
import numpy as np
from src.dynamics.arm2dof import Arm2DOF
arm = Arm2DOF()
x_hang = np.zeros(4)                      # hanging straight down
x_side = np.array([np.pi/2, 0, 0, 0])    # first link horizontal

# G should be [0,0] at hanging, [9.81, 2.45] at horizontal
print('G at hang:', arm.get_gravity(x_hang[:2]))
print('G at side:', arm.get_gravity(x_side[:2]))

# M should be [[0.667, 0.208],[0.208, 0.083]] at q2=0
print('M at q=[0,0]:', arm.get_M(x_hang[:2]))

# f(x_hang, u=G) should be ~zero (equilibrium)
u_eq = arm.get_gravity(x_hang[:2])
print('áº‹ at equilibrium:', arm.f_fun(x_hang, u_eq))
"</div>

<h2>Step 2 â€” Verify Linearisation (10 min)</h2>
<div class="cb"><div class="ct">Compare Ac, Bc against hand formulas for Case B</div>python3 -c "
from src.utils.qp_inspector import inspect_linearisation
inspect_linearisation('B')   # should match Â§4 Case B derivation

# Expected Ac lower-left:
# [[-25.226, 25.226], [33.634, -92.494]]
# Expected Bc lower rows:
# [[6.857, -17.143], [-17.143, 54.857]]
"</div>

<h2>Step 3 â€” Verify QP Matrix Assembly (10 min)</h2>
<div class="cb"><div class="ct">Check matrix shapes and key entries</div>python3 -c "
from src.utils.qp_inspector import build_case, print_matrices
r = build_case('A')
Q, p, A_eq, b_eq, A_ineq, k_ineq = r['qp_matrices']
N = r['N']

print('=== SHAPES ===')
print('Q:', Q.shape)       # expect (14,14) for N=1
print('A_eq:', A_eq.shape) # expect (8,14)
print('A_ineq:', A_ineq.shape) # expect (16,14)

print('=== KEY CHECKS ===')
print('A_eq[0:4,0:4] should be I:', A_eq[:4,:4])
print('A_eq[4:8,6:10] should be I:', A_eq[4:8,6:10])
print('Q diagonal (first 10):', Q.diagonal()[:10])
print('A_ineq torque rows (u cols 4-5):', A_ineq[:4, 4:6])
"</div>

<h2>Step 4 â€” Verify OSQP Solution (10 min)</h2>
<div class="cb"><div class="ct">Run all cases and check KKT residuals</div>python3 -c "
from src.utils.qp_inspector import run_all_cases
run_all_cases(verbose=True)
# All cases should print: PASS (eq_norm â‰¤ 1e-4, ineq_viol â‰¤ 1e-4, kkt_resid â‰¤ 1e-2)
"</div>

<h2>Step 5 â€” Verify Main Simulation (15 min)</h2>
<div class="cb"><div class="ct">Run full simulation and inspect logged QP at step 0</div>python3 src/main.py --export_qp --dataset_dir results/test_run/

# Check the exported matrices match what qp_inspector gives:
python3 -c "
import numpy as np
data = np.load('results/test_run/qp_step0_debug.npz')
print('Keys:', list(data.keys()))
print('Q shape:', data['Q'].shape)
print('Q diag[:6]:', np.diag(data['Q'])[:6])
print('x0:', data['x0'])
print('Params [m1,m2,l1,l2,g]:', data['params'])
"</div>

<h2>Step 6 â€” Verify Interactive Visualization (5 min)</h2>
<div class="cb"><div class="ct">Run interactive arm and check all toggles</div>python3 interactive_arm.py --gravity 9.81

# Manual checks:
# 1. Click goal near q=[0.5, 0.3] â†’ arm should move to goal
# 2. Click "Gravity ON/OFF" â†’ arm should fall/freeze
# 3. Click "MPC ON/OFF" â†’ arm should drift with gravity only
# 4. Re-enable MPC â†’ arm should recover
</div>

<h2>Diagnostic Hints</h2>

<table class="tbl">
<tr><th>Symptom</th><th>Likely cause</th><th>Fix</th></tr>
<tr><td>OSQP returns "infeasible"</td><td>Hard torque bounds too tight for required gravity compensation</td><td>Increase Ï„_max or use soft torque bounds</td></tr>
<tr><td>Arm oscillates badly</td><td>R too small (allows large u), N too short</td><td>Increase R[0,0] or increase N</td></tr>
<tr><td>verify_solution fails eq_norm</td><td>Check c_k computation (sign of Aâ‚“Â·xÌ„ term)</td><td>Print c_k and compare to hand formula</td></tr>
<tr><td>Ac lower-right = 0 everywhere</td><td>Expected! Reference velocities = 0 always</td><td>Use inspect_at_point for non-zero velocity</td></tr>
<tr><td>KKT residual large</td><td>OSQP eps_abs too loose</td><td>Set eps_abs=1e-6 in OSQPSolver for testing</td></tr>
<tr><td>u* = 0 for N=1 position cost</td><td>Expected! See Â§8 analysis</td><td>Increase N or add velocity cost term to Qf</td></tr>
</table>

<hr>

<!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SECTION 14 -->
<h1 id="s14">14 Â· References</h1>

<div class="ref">
<div class="rt">[1] Stellato, B., Banjac, G., Goulart, P., Bemporad, A., Boyd, S.
"OSQP: an operator splitting solver for quadratic programs."
<em>Mathematical Programming Computation</em> 12, 637â€“672 (2020).</div>
<div class="rq">"We consider convex QPs of the form: min Â½xáµ€Px + qáµ€x s.t. l â‰¤ Ax â‰¤ u,
where xâˆˆâ„â¿, Pâˆˆğ•Šâ¿â‚Š, Aâˆˆâ„áµË£â¿, qâˆˆâ„â¿, lâˆˆ(â„âˆª{âˆ’âˆ})áµ, uâˆˆ(â„âˆª{+âˆ})áµ." (Â§1, Eq. 1)</div>
<a href="https://doi.org/10.1007/s12532-020-00179-2">doi:10.1007/s12532-020-00179-2</a>
</div>

<div class="ref">
<div class="rt">[2] Rawlings, J.B., Mayne, D.Q., Diehl, M.
<em>Model Predictive Control: Theory, Computation, and Design</em>, 2nd ed. Nob Hill (2017).</div>
<div class="rq">"The fundamental idea of MPC is to optimize predicted future behaviourâ€¦ using a finite-horizon
open-loop optimal control problem solved at each sampling instant." (Ch. 1)</div>
</div>

<div class="ref">
<div class="rt">[3] Murray, R.M., Li, Z., Sastry, S.S.
<em>A Mathematical Introduction to Robotic Manipulation</em>. CRC Press (1994).</div>
<div class="rq">"The Lagrangian equations of motion for an n-link robot manipulator are:
M(q)qÌˆ + C(q,qÌ‡)qÌ‡ + g(q) = Ï„, where M is the inertia matrix, C is the Coriolis and centripetal
matrix, and g is the gravity vector." (Ch. 4, Eq. 4.29)</div>
<a href="http://www.cds.caltech.edu/~murray/mlswiki/">cds.caltech.edu/~murray/mlswiki</a>
</div>

<div class="ref">
<div class="rt">[4] Andersson, J.A.E., Gillis, J., Horn, G., Rawlings, J.B., Diehl, M.
"CasADi: A software framework for nonlinear optimization and optimal control."
<em>Mathematical Programming Computation</em> 11, 1â€“36 (2019).</div>
<div class="rq">"CasADi is an open-source tool for nonlinear optimization and algorithmic differentiation.
It facilitates rapid â€” yet efficient â€” implementation of different methods for numerical optimal control,
both in an offline context and for nonlinear model predictive control (NMPC)." (Abstract)</div>
<a href="https://doi.org/10.1007/s12532-018-0139-4">doi:10.1007/s12532-018-0139-4</a>
</div>

<div class="ref">
<div class="rt">[5] Spong, M.W., Hutchinson, S., Vidyasagar, M.
<em>Robot Modeling and Control</em>. Wiley (2006).</div>
<div class="rq">"For a uniform rod of mass m and length l, the moment of inertia about the proximal end
is mlÂ²/3." (Appendix B, Table B.1)</div>
</div>

<hr style="margin-top:60px">
<p style="text-align:center;color:#9ca3af;font-family:sans-serif;font-size:.8rem">
Study Guide v3 Â· Built from codebase inspection + CasADi verified derivations Â·
All numerical results reproducible via <code>src/utils/qp_inspector.py</code>
</p>

</body>
</html>






